---
layout:     post
title:      "翻译：The Llama 3 Herd of Models" 
author:     "lili" 
mathjax: true
sticky: false
excerpt_separator: <!--more-->
tags:
    - LLM
    - Llama 3
---

本文分析阅读The Llama 3 Herd of Models。

<!--more-->

**目录**
* TOC
{:toc}


现代人工智能（AI）系统由基础模型驱动。本文介绍了一套新的基础模型，称为Llama 3。它是一群本地支持多语言、编码、推理和工具使用的语言模型。我们最大的模型是一个具有4050亿参数和高达128K令牌上下文窗口的密集Transformer。本文对Llama 3进行了广泛的实证评估。我们发现Llama 3在众多任务上提供了与GPT-4等领先语言模型相当的质量。我们公开发布了Llama 3，包括4050亿参数语言模型的预训练和后训练版本，以及我们的Llama Guard 3模型，用于输入和输出安全。本文还介绍了我们通过组合方法将图像、视频和语音能力集成到Llama 3中的实验结果。我们观察到这种方法在图像、视频和语音识别任务上与最先进的技术竞争。生成的模型尚未广泛发布，因为它们仍在开发中。

## 1 引言

基础模型是为语言、视觉、语音和/或其他模态设计的通用模型，旨在支持大量AI任务。它们构成了许多现代AI系统的基础。

现代基础模型的发展包括两个主要阶段：(1) 预训练阶段，在这个阶段，模型使用简单的任务（如下一个词预测或字幕生成）进行大规模训练；(2) 后训练阶段，在这个阶段，模型被调整以遵循指令、与人类偏好对齐，并提高特定能力（例如，编码和推理）。

在本文中，我们介绍了一套新的语言基础模型，称为Llama 3。Llama 3模型群原生的支持多语言、编码、推理和工具使用。我们最大的模型是一个具有4050亿参数的密集Transformer，能够在高达128K令牌的上下文中处理信息。表1列出了每个模型成员。本文中呈现的所有结果都是针对Llama 3.1模型的，为了简洁，我们将在全文中称之为Llama 3。

<a>![](/img/llama3/1.png)</a>
*表1 Llama 3模型群的概览。本文中的所有结果都是针对Llama 3.1模型的。*

我们相信，在开发高质量的基础模型方面有三个关键的杠杆：数据、规模和管理复杂性。我们在开发过程中寻求优化这三个杠杆：

* 数据。与Llama的早期版本（Touvron等人，2023a，b）相比，我们改进了用于预训练和后训练的数据量和质量。这些改进包括开发更谨慎的预训练数据处理和策划流程，以及为后训练数据开发更严格的质量保证和过滤方法。我们对Llama 3进行了大约15T多语言令牌的预训练，而Llama 2是1.8T令牌。

* 规模。我们训练的模型规模远远大于以前的Llama模型：我们的旗舰语言模型使用了$3.8 \times 10^{25}$次浮点运算进行预训练，比Llama 2的最大版本多近50倍。具体来说，我们在15.6T文本令牌上预训练了一个具有4050亿可训练参数的旗舰模型。根据基础模型的规模法则，我们的旗舰模型的表现超过了使用相同过程训练的较小模型。虽然我们的规模法则表明，我们的旗舰模型对于我们的训练预算来说是近似计算最优的大小，我们还训练了更小的模型，比计算最优的时间长得多。产生的模型在相同的推理预算下比计算最优模型表现更好。我们使用旗舰模型在后训练期间进一步提高这些较小模型的质量。

* 管理复杂性。我们做出设计选择，力求最大化我们扩展模型开发过程的能力。例如，我们选择标准的密集Transformer模型架构（Vaswani等人，2017）进行小幅度调整，而不是选择专家混合模型（Shazeer等人，2017）以最大化训练稳定性。同样，我们采用了相对简单的后训练程序，基于监督微调（SFT）、拒绝采样（RS）和直接偏好优化（DPO；Rafailov等人（2023）），而不是更复杂的强化学习算法（Ouyang等人，2022；Schulman等人，2017），这些算法往往不太稳定，更难扩展。


我们的工作成果是Llama 3：一个包含8B、70B和405B参数的三种多语言的语言模型的群体。我们在涵盖广泛语言理解任务的众多基准数据集上评估了Llama 3的性能。此外，我们进行了广泛的人类评估，将Llama 3与竞争模型进行了比较。表2展示了旗舰Llama 3模型在关键基准测试中的表现概览。我们的实验评估表明，我们的旗舰模型在各种任务上的表现与GPT-4（OpenAI，2023a）等领先的语言模型相当，并且接近于达到最先进的水平。我们的较小模型是同类中最好的，超过了参数数量相似的替代模型（Bai等人，2023；Jiang等人，2023）。Llama 3还在有益性和无害性之间提供了比其前身（Touvron等人，2023b）更好的平衡。我们在第5.4节中对Llama 3的安全性进行了详细分析。

<a>![](/img/llama3/2.png)</a>
**表2 在关键基准评估中微调后的Llama 3模型的性能。该表比较了8B、70B和405B版本的Llama 3与竞争模型的性能。我们在三种模型尺寸等级中，每个等级中表现最佳模型的结果用粗体表示。△表示使用5次提示（无CoT）获得的结果。◁表示未使用CoT获得的结果。ᛜ表示使用零次提示获得的结果。**

我们正在根据Llama 3社区许可证的更新版本公开发布所有三个Llama 3模型；请参见 https://llama.meta.com。这包括我们的405B参数语言模型的预训练和后训练版本，以及我们的Llama Guard模型（Inan等人，2023）的新版本，用于输入和输出安全。我们希望旗舰模型的开放发布将激发研究社区的一波创新，并加速朝着负责任的人工通用智能（AGI）发展道路前进。

作为Llama 3开发过程的一部分，我们还开发了模型的多模态扩展，使其具备图像识别、视频识别和语音理解能力。这些模型仍在积极开发中，尚未准备好发布。除了我们的语言建模结果外，本文还展示了我们对这些多模态模型进行的初步实验的结果。

## 2 概述

<a>![](/img/llama3/3.png)</a>
**图1 Llama 3的整体架构和训练示意图。Llama 3是一个Transformer语言模型，被训练用于预测文本序列的下一个标记。详见正文。**

Llama 3的模型架构在图1中进行了说明。我们Llama 3语言模型的开发包括两个主要阶段：

* 语言模型预训练。我们首先将一个大型多语言文本语料库转换为离散的标记，并在生成的数据上预训练一个大型语言模型（LLM）以执行下一个标记预测。在语言模型预训练阶段，模型学习语言的结构，并从它“阅读”的文本中获得大量关于世界的知识。为了有效地做到这一点，预训练是在大规模上进行的：我们在8K标记的上下文中，使用15.6T标记预训练了一个具有4050亿参数的模型。这个标准的预训练阶段之后是一个持续预训练阶段，它将支持的上下文窗口增加到128K标记。见第3节了解详细信息。

* 语言模型后训练。预训练的语言模型对语言有丰富的理解，但尚未遵循指令或以我们期望助手表现的方式行事。我们通过几轮人类反馈来调整模型，每轮都涉及在指令调整数据上进行监督微调（SFT）和直接偏好优化（DPO；Rafailov等人，2024）。在这个后训练阶段，我们还整合了新的能力，例如工具使用，并观察到在其他领域，如编码和推理方面的显著改进。见第4节了解详细信息。最后，安全缓解措施也在后训练阶段整合到模型中，具体细节在第5.4节中描述。

生成的模型具有丰富的功能集。它们可以用至少八种语言回答问题，编写高质量的代码，解决复杂的推理问题，并开箱即用或以零样本方式使用工具。我们还进行实验，通过组合方法将图像、视频和语音能力添加到Llama 3中。我们研究的方法包括图28所示的三个附加阶段：

* 多模态编码器预训练。我们为图像和语音训练单独的编码器。我们在大量图像-文本对上训练我们的图像编码器。这教会了模型视觉内容与自然语言中对该内容描述之间的关系。我们的语音编码器是使用一种自监督方法训练的，该方法遮蔽输入语音的部分并尝试通过离散标记表示重构被遮蔽的部分。结果，模型学习了语音信号的结构。见第7节了解图像编码器的详细信息和第8节了解语音编码器的详细信息。

* 视觉适配器训练。我们训练一个适配器，将预训练的图像编码器集成到预训练的语言模型中。适配器由一系列交叉注意力层组成，将图像编码器的表示输入到语言模型中。适配器在文本-图像对上进行训练。这将图像表示与语言表示对齐。在适配器训练期间，我们还更新了图像编码器的参数，但我们故意不更新语言模型的参数。我们还基于图像适配器在配对视频-文本数据上训练了一个视频适配器。这使模型能够跨帧聚合信息。见第7节了解详细信息。

* 语音适配器训练。最后，我们通过一个适配器将语音编码器集成到模型中，该适配器将语音编码转换为可以直接输入到微调后的语言模型中的标记表示。在监督微调阶段，适配器和编码器的参数被联合更新，以实现高质量的语音理解。在语音适配器训练期间，我们不更改语言模型。我们还集成了一个文本到语音系统。见第8节了解详细信息。

我们的多模态实验导致模型能够识别图像和视频的内容，并通过语音接口支持交互。这些模型仍在开发中，尚未准备好发布。


## 3 预训练

语言模型预训练包括：(1) 大规模训练语料库的策划和过滤，(2) 开发模型架构和相应的规模法则以确定模型大小，(3) 开发大规模高效预训练技术，以及(4) 开发预训练配方。我们在下面分别介绍这些组成部分。

### 3.1 预训练数据

我们从包含直到2023年底的知识的多种数据源中创建语言模型预训练数据集。我们对每个数据源应用了几种去重方法和数据清洗机制，以获得高质量的标记。我们移除了包含大量个人可识别信息（PII）的域名(Domain)，以及已知含有成人内容的域名。

#### 3.1.1 网络数据策划(Curation)

我们使用的大部分数据来自网络，我们下面描述我们的清洗过程。

**PII和安全过滤**。在其他缓解措施中，我们实施了旨在移除可能包含不安全内容或大量PII数据的网站数据的过滤器，根据各种Meta安全标准被评为有害的域名，以及已知含有成人内容的域名。

**文本提取和清洗**。我们处理非截断网页文档的原始HTML内容，提取高质量多样化文本。为此，我们构建了一个自定义解析器，提取HTML内容，并优化了在去除通用模板和内容召回方面的精确度。我们通过人类评估来评估我们解析器的质量，将其与优化文章类内容的流行的第三方HTML解析器进行比较，并发现它表现良好。我们仔细处理包含数学和代码内容的HTML页面，以保留该内容的结构。我们保留图像alt属性文本，因为数学内容通常表示为预先渲染的图像，其中alt属性也提供了数学内容。我们实验性地评估不同的清洗配置。我们发现，与纯文本相比，Markdown对主要在网络数据上训练的模型的性能有害，因此我们移除了所有Markdown标记。

**去重**。我们在URL、文档和行级别应用了几轮去重：

* URL级别去重。我们对整个数据集进行URL级别去重。我们保留每个URL对应页面的最新版本。
* 文档级别去重。我们对整个数据集进行全局MinHash去重，以移除几乎重复的文档。
* 行级别去重。我们执行与ccNet类似的积极行级别去重。我们移除在每30M文档的桶中出现超过6次的行。

尽管我们的手动定性分析显示，行级别去重不仅移除了来自各种网站（如导航菜单、Cookie警告）的剩余通用模板，还移除了频繁出现的高质量文本，但我们的实证评估显示了强有力的改进。

**启发式过滤**。我们开发了启发式规则，以移除额外的低质量文档、异常值和重复过多的文档。一些启发式的例子包括：

* 我们使用重复n-gram覆盖率（Rae等人，2021）来移除由重复内容（如日志记录或错误消息）组成的行。这些行可能非常长且唯一，因此无法通过行去重过滤。
* 我们使用“脏字”计数（Raffel等人，2020）来过滤出不在域名阻止列表覆盖范围内的成人网站。
* 我们使用令牌分布Kullback-Leibler散度来过滤出与训练语料库分布相比含有过多异常令牌的文档。

**基于模型的质量过滤**。此外，我们尝试应用各种基于模型的质量分类器来选择高质量的标记。这些包括使用fasttext（Joulin等人，2017）这样的快速分类器，训练以识别给定文本是否会被维基百科引用（Touvron等人，2023a），以及更计算密集的基于Roberta的分类器（Liu等人，2019a）在Llama 2预测上训练。为了基于Llama 2训练一个质量分类器，我们创建了一个清洗过的网络文档的训练集，描述了质量要求，并指示Llama 2的聊天模型确定文档是否满足这些要求。我们使用DistilRoberta（Sanh等人，2019）为每个文档生成质量分数，以提高效率。我们通过实验评估了各种质量过滤配置的有效性。

**代码和推理数据**。与DeepSeek-AI等人（2024）类似，我们构建了特定领域的管道，提取代码和与数学相关的网页。具体来说，代码和推理分类器都是基于Llama 2在网络数据上进行训练的DistilledRoberta模型。与上述一般质量分类器不同，我们进行了提示调整，以针对包含数学演绎、STEM领域的推理和与自然语言交织的代码的网页。由于代码和数学的令牌分布与自然语言的分布大不相同，这些管道实现了特定领域的HTML提取、定制的文本特征和过滤启发式规则。

**多语言数据**。与我们上面描述的英文处理管道类似，我们实施了过滤器，以移除可能包含PII或不安全内容的网站的数据。我们的多语言文本处理管道有几个独特的特点：

* 我们使用基于fasttext的语言识别模型将文档分类为176种语言。
* 我们在每种语言的数据中执行文档级别和行级别的去重。
* 我们应用特定语言的启发式和基于模型的过滤器来移除低质量文档。

此外，我们使用基于多语言Llama 2的分类器对多语言文档进行质量排名，以确保优先考虑高质量内容。我们通过实验确定预训练中使用的多语言标记的数量，平衡模型在英文和多语言基准上的性能。

#### 3.1.2 确定数据混合

要获得高质量的语言模型，仔细确定预训练数据混合中不同数据源的比例至关重要。我们在确定数据混合的主要工具是知识分类和规模法则实验。

**知识分类**。我们开发了一个分类器，对我们的网络数据包含的信息类型进行分类，以更有效地确定数据混合。我们使用这个分类器来降低在网络上过度表示的数据类别，例如艺术和娱乐。

**数据混合的规模法则**。为确定最佳数据混合，我们执行规模法则实验，其中我们训练几个小型模型在数据混合上，并使用该数据混合预测大型模型在该混合上的性能（见第3.2.1节）。我们多次重复这个过程，以选择不同的数据混合，然后在这个候选数据混合上训练一个更大的模型，并评估该模型在几个关键基准上的性能。

**数据混合摘要**。我们最终的数据混合大致包含50%的对应于一般知识标记，25%的数学和推理标记，17%的代码标记，以及8%的多语言标记。
 
#### 3.1.3 数据退火处理

通过实证研究，我们发现在小量的高质量代码和数学数据上进行退火处理（见3.4.3节）可以提升预训练模型在关键基准测试上的性能。与Li等人（2024b）类似，我们使用一种数据混合进行退火处理，该混合在选定的领域中上采样了高质量数据。在我们的退火数据中，我们不包括常用基准测试中的任何训练集。这使我们能够评估Llama 3的真实少次学习能力和跨领域泛化能力。

遵循OpenAI（2023a），我们评估了在GSM8k（Cobbe等人，2021）和MATH（Hendrycks等人，2021b）训练集上进行退火处理的有效性。我们发现，退火处理改善了预训练的Llama 3 8B模型在GSM8k和MATH验证集上的性能，分别提高了24.0%和6.4%。然而，在405B模型上的性能提升可以忽略不计，这表明我们的旗舰模型具有强大的上下文学习和推理能力，不需要特定的领域内训练样本就能获得出色的性能。

**利用退火评估数据质量**。与Blakeney等人（2024）类似，我们发现退火使我们能够判断小规模特定领域数据集的价值。我们通过将一个训练了50%的Llama 3 8B模型的学习率在线性地退火到0的40B个令牌上，来衡量这些数据集的价值。在这些实验中，我们给新数据集分配了30%的权重，其余70%的权重分配给了默认数据混合。使用退火来评估新数据源比为每个小数据集执行规模法则实验更有效率。


### 3.2 模型架构

Llama 3 使用标准的密集Transformer架构（Vaswani等人，2017）。在模型架构方面，它与Llama和Llama 2（Touvron等人，2023a,b）相比没有显著偏离；我们的性能提升主要是由于数据质量和多样性的提高以及训练规模的增加。

与Llama 3相比，我们做了一些小的修改：

* 我们使用分组查询注意力（GQA；Ainslie等人，2023）和8个键值头来提高推理速度，并在解码过程中减少键值缓存的大小。
* 我们使用注意力掩码来防止同一序列内不同文档之间的自注意力。我们发现这一变化在标准预训练中的影响有限，但在对非常长序列的持续预训练中很重要。
* 我们使用一个128K令牌的词汇表。我们的令牌词汇表结合了来自tiktoken3分词器的100K令牌和额外的28K令牌，以更好地支持非英语语言。与Llama 2分词器相比，我们的新分词器将样本英语数据的压缩率从3.17提高到3.94个字符每令牌。这使模型能够在相同的训练计算量下“阅读”更多的文本。我们还发现，添加来自选定非英语语言的28K令牌既提高了压缩比率，也提高了下游性能，而对英语分词没有影响。
* 我们将RoPE基础频率超参数增加到500,000。这使我们能够更好地支持更长的上下文；Xiong等人（2023）表明，这个值对于长达32,768的上下文是有效的。

Llama 3 405B使用了一个具有126层、16,384个令牌表示维度和128个注意力头的架构；详见表3。这导致模型大小根据我们数据上的规模法则，对于我们的$3.8 \times 10^{25}$ FLOPs训练预算来说，是大约计算最优的。

<a>![](/img/llama3/4.png)</a>
*表3 Llama 3的关键超参数概览。我们为8B、70B和405B语言模型显示了设置。*

#### 3.2.1 规模法则

我们发展规模法则（Hoffmann等人，2022；Kaplan等人，2020）来确定我们的旗舰模型的最优大小，考虑到我们的预训练计算预算。除了确定最优模型大小之外，一个主要挑战是预测旗舰模型在下游基准任务上的性能，由于几个问题：(1)现有的规模法则通常只预测下一个标记预测损失，而不是特定的基准性能。(2)规模法则可能嘈杂且不可靠，因为它们是基于使用小计算预算进行的预训练运行来发展的（Wei等人，2022b）。

为了应对这些挑战，我们实施了一个两阶段方法来发展能够准确预测下游基准性能的规模法则：

1. 我们首先建立计算最优模型在下游任务上的负对数似然与训练FLOPs之间的相关性。
2. 接下来，我们利用规模法则模型和使用更高计算FLOPs训练的旧模型，将下游任务上的负对数似然与任务准确率相关联。在这一步中，我们特别利用了Llama 2系列模型。

这种方法使我们能够在给定特定数量的训练FLOPs的情况下，为计算最优模型预测下游任务的性能。我们使用类似的方法选择我们的预训练数据混合（见第3.4节）。

**规模法则实验**。具体来说，我们通过在$6 \times 10^{18}$ FLOPs到$10^{22}$ FLOPs之间的计算预算下预训练模型来构建我们的规模法则。在每个计算预算下，我们预训练大小在4000万到160亿参数之间的模型，每个计算预算下使用子集的模型大小。在这些训练运行中，我们使用余弦学习率计划，并在2000个训练步骤中进行线性预热。峰值学习率根据模型大小设置在$2 \times 10^{-4}$到$4 \times 10^{-4}$之间。我们将余弦衰减设置为峰值的0.1。每个步骤的权重衰减设置为该步骤学习率的0.1倍。我们为每个计算规模使用固定的批量大小，范围在25万到400万之间。

这些实验产生了图2中的IsoFLOPs曲线。这些曲线上的损失是在单独的验证集上测量的。我们使用二度多项式拟合测量的损失值，并确定每个抛物线的最小值。我们将抛物线的最小值称为相应预训练计算预算的计算最优模型。

<a>![](/img/llama3/5.png)</a>
**图2 在$6 \times 10^{18}$到$10^{22}$ FLOPs之间的规模法则IsoFLOPs曲线。损失是在一个保留的验证集上的负对数似然。我们使用二度多项式近似每个计算规模的测量值。**

我们用这种方式识别出的计算最优模型来预测特定计算预算下的最佳训练令牌数量。为此，我们假设计算预算C和最佳训练令牌数量$N^*(C)$之间存在幂律关系：

$$
N^*(C)=AC^{\alpha}
$$

我们使用图2中的数据拟合A和α。我们发现(α, A) = (0.53, 0.29)；相应的拟合显示在图3中。将结果规模法则外推到$3.8 \times 10^{25}$ FLOPs建议在16.55T令牌上训练一个402B参数模型。

<a>![](/img/llama3/7.png)</a>
**图3 被识别的计算最优模型中的训练令牌数量与预训练计算预算的函数关系。我们也包括了拟合的规模法则预测。计算最优模型对应于图2中的抛物线最小值。**

一个重要的观察是，随着计算预算的增加，IsoFLOPs曲线在最小值附近变得更平。这意味着旗舰模型的性能对于模型大小和训练令牌之间的权衡的小变化相对稳健。基于这一观察，我们最终决定训练一个具有4050亿参数的旗舰模型。

**预测下游任务的性能**。我们使用结果中的计算最优模型来预测旗舰Llama 3模型在基准数据集上的性能。首先，我们线性相关基准中正确答案的（归一化的）负对数似然和训练FLOPs。在这个分析中，我们只使用在上述数据混合上训练到$10^{22}$ FLOPs的规模法则模型。接下来，我们使用规模法则模型和Llama 2模型建立对数似然和准确率之间的S形关系，这些模型是使用Llama 2数据混合和分词器训练的。我们在图4中展示了这个实验的结果（ARC挑战基准）。我们发现这个两步规模法则预测，它在四个数量级上进行外推，相当准确：它只是略微低估了旗舰Llama 3模型的最终性能。

<a>![](/img/llama3/6.png)</a>
**图4 ARC挑战的规模法则预测。左侧：在ARC挑战基准测试中，正确答案的归一化负对数似然作为预训练FLOPs的函数。右侧：ARC挑战基准测试的准确率作为正确答案的归一化负对数似然的函数。这种分析使我们能够在预训练开始之前预测模型在ARC挑战基准测试上的性能。详见正文。**

### 3.3 基础设施、扩展和效率
我们描述了支持Llama 3 405B大规模预训练的硬件和基础设施，并讨论了几项优化，这些优化带来了训练效率的提升。

#### 3.3.1 训练基础设施
Llama 1和2模型是在Meta的AI研究超级集群（Lee和Sengupta，2022）上训练的。随着我们进一步扩展，Llama 3的训练转移到了Meta的生产集群（Lee等人，2024）。这个设置优化了生产级别的可靠性，这对于我们扩大训练规模至关重要。

**计算**。Llama 3 405B在多达16K个H100 GPU上进行训练，每个GPU运行700W TDP(Thermal Design Power)，配备80GB HBM3，使用Meta的Grand Teton AI服务器平台（Matt Bowman，2022）。每个服务器配备八个GPU和两个CPU。在服务器内，八个GPU通过NVLink连接。使用MAST（Choudhury等人，2024）调度训练作业，这是Meta的全球规模训练调度器。

**存储**。Tectonic（Pan等人，2021），Meta的通用分布式文件系统，用于构建Llama 3预训练的存储网络（Battey和Gupta，2024）。它提供了7500台配备SSD的服务器中的240PB存储空间，并支持持续吞吐量2TB/s和峰值吞吐量7TB/s。一个主要挑战是支持高突发性的检查点写入，这些写入在短时间内饱和存储网络。检查点保存每个GPU的模型状态，范围从每个GPU的1MB到4GB，用于恢复和调试。我们的目标是最小化检查点期间GPU的暂停时间，并增加检查点频率，以减少恢复后丢失的工作量。

**网络**。Llama 3 405B使用了基于Arista 7800和Minipack2开放计算项目4 OCP机架交换机的RDMA over Converged Ethernet (RoCE)网络。Llama 3家族的较小模型使用Nvidia Quantum2 Infiniband网络进行训练。RoCE和Infiniband集群都在GPU之间利用400Gbps互连。尽管这些集群的底层网络技术存在差异，但我们调整了它们，以提供这些大型训练工作负载的等效性能。我们将更详细地介绍我们的RoCE网络，因为我们完全拥有其设计。

* 网络拓扑。我们的基于RoCE的AI集群由24K GPU连接，由三层Clos网络（Lee等人，2024）组成。在底层，每个机架托管16个GPU，分布在两台服务器上，并通过单个Minipack2机架顶部（ToR）交换机连接。在中间层，192个这样的机架通过集群交换机连接，形成一个拥有3072 GPU的吊舱，具有完整的双工带宽，确保没有过订(oversubscription)。在顶层，同一数据中心大楼内的八个这样的吊舱通过聚合交换机连接，形成一个24K GPU的集群。然而，聚合层的网络连接没有保持完整的双工带宽，而是有一个1:7的过订比率。我们的模型并行方法（见第3.3.2节）和训练作业调度器（Choudhury等人，2024）都针对网络拓扑进行了优化，旨在最小化跨吊舱的网络通信。

* 负载均衡。LLM训练产生难以使用传统方法（如等成本多路径（ECMP）路由）在所有可用网络路径上进行负载均衡的胖网络流。为解决这一挑战，我们采用了两种技术。首先，我们的集合库在两个GPU之间创建16个网络流，而不是仅仅一个，从而减少了每个流的流量，并为负载均衡提供了更多的流。其次，我们的增强ECMP（E-ECMP）协议通过在RoCE数据包头中散列额外字段，有效地在不同网络路径上平衡这16个流。

* 拥塞控制。我们使用深缓冲交换机在主干（Gangidi等人，2024）中容纳由集合通信模式引起的瞬态拥塞和缓冲。这种设置有助于限制由慢服务器引起的持续拥塞和网络反压的影响，这在训练中很常见。最后，通过E-ECMP的更好负载均衡显著降低了拥塞的可能性。通过这些优化，我们成功地运行了一个24K GPU集群，而无需使用传统的拥塞控制方法，如数据中心量化拥塞通知（DCQCN）。

#### 3.3.2 模型扩展的并行性

为了扩展我们最大模型的训练，我们使用4D并行性——四种不同类型的并行方法的组合——来分片模型。这种方法有效地在许多GPU上分布计算，并确保每个GPU的模型参数、优化器状态、梯度和激活适合其HBM。我们在图5中展示了4D并行性的实现。它结合了张量并行性（TP；Krizhevsky等人（2012）；Shoeybi等人（2019）；Korthikanti等人（2023））、流水线并行性（PP；Huang等人（2019）；Narayanan等人（2021）；Lamy-Poirier（2023））、上下文并行性（CP；Liu等人（2023a））和数据并行性（DP；Rajbhandari等人（2020）；Ren等人（2021）；Zhao等人（2023b））。

<a>![](/img/llama3/8.png)</a>
**图5 4D并行性的示意图。GPU按照[TP, CP, PP, DP]的顺序被划分为并行组，其中DP代表FSDP。在这个例子中，16个GPU被配置为组大小为|TP|=2, |CP|=2, |PP|=2, 和 |DP|=2。GPU在4D并行中的位置被表示为一个向量，[D1, D2, D3, D4]，其中Di是第i个并行维度上的索引。在这个例子中，GPU0[TP0, CP0, PP0, DP0]和GPU1[TP1, CP0, PP0, DP0]在同一个TP组中，GPU0和GPU2在同一个CP组中，GPU0和GPU4在同一个PP组中，GPU0和GPU8在同一个DP组中。**


张量并行性将个别权重张量分割成不同设备上的多个块。流水线并行性通过层垂直划分模型，使不同的设备可以并行处理完整模型流水线的不同阶段。上下文并行性将输入上下文分割成段，减少了非常长序列长度输入的内存瓶颈。我们使用完全分片的数据并行性（FSDP；Rajbhandari等人，2020；Ren等人，2021；Zhao等人，2023b），它在实现数据并行性的同时分片模型、优化器和梯度，数据并行性在多个GPU上并行处理数据，并在每个训练步骤后同步。我们对Llama 3使用FSDP的方式是分片优化器状态和梯度，但对于模型分片我们没有在前向计算后重新分片，以避免在后向传递期间进行额外的全收集通信。

**GPU利用率**。通过仔细调整并行配置、硬件和软件，我们在表4所示的配置中实现了整体BF16模型FLOPs利用率（MFU；Chowdhery等人（2023））为38-43%。在16K GPU上，DP=128的MFU略微下降到41%，而8K GPU上，DP=64的MFU为43%，这是由于在训练期间需要保持全局批次中的令牌数量不变，因此每个DP组的批量大小较低。


<a>![](/img/llama3/9.png)</a>
*表4 Llama 3 405B预训练各阶段的扩展配置和MFU（模型FLOPs利用率）。详见文本和图5，了解每种并行类型的描述。*

**流水线并行性改进**。我们在使用现有实现时遇到了几个挑战：

* 批量大小限制。当前实现对每个GPU支持的批量大小有限制，要求它能够被流水线阶段的数量整除。例如，在图6中，流水线并行性的深度优先调度（DFS）要求N = PP = 4，而广度优先调度（BFS；Lamy-Poirier（2023））要求N = M，其中M是微批次的总数，N是同一阶段的前向或后向的连续微批次的数量。然而，预训练通常需要灵活性来调整批量大小。
* 内存不平衡。现有的流水线并行性实现导致资源消耗不平衡。第一阶段由于嵌入和预热微批次而消耗更多的内存。
* 计算不平衡。在模型的最后一层之后，我们需要计算输出和损失，使这个阶段成为执行延迟瓶颈。

为解决这些问题，我们修改了我们的流水线调度，如图6所示，它允许灵活设置N——在这种情况下N = 5，可以运行每个批次中的任意数量的微批次。这允许我们运行：(1)在大规模时，比阶段数量少的微批次，当我们有批量大小限制；(2)更多的微批次来隐藏点对点通信，找到DFS和BFS的最佳通信和内存效率之间的平衡点。为了平衡流水线，我们分别从第一阶段和最后阶段减少了一个Transformer层。这意味着第一阶段的第一个模型块只有嵌入，最后阶段的最后一个模型块只有输出投影和损失计算。为了减少流水线气泡，我们使用了一个交错调度（Narayanan等人，2021）在V个流水线阶段上运行一个流水线等级。总体流水线气泡比率是$\frac{PP−1}{V ∗ M}$。此外，我们采用流水线中的异步点对点通信，这大大加快了训练速度，特别是在文档掩码引入额外计算不平衡的情况下。我们启用TORCH_NCCL_AVOID_RECORD_STREAMS来减少异步点对点通信的内存使用。最后，为了减少内存成本，基于详细的内存分配分析，我们主动释放了将来不会用于计算的张量，包括每个流水线阶段的输入和输出张量，这些张量将来不会用于计算。通过这些优化，我们能够在没有激活检查点的情况下预训练Llama 3在8K令牌序列上。

<a>![](/img/llama3/10.png)</a>
**图6 Llama 3中的流水线并行性示意图。流水线并行性将八个流水线阶段（0到7）划分到四个流水线等级（PP等级0到3）上，其中等级为0的GPU运行阶段0和4，等级为1的GPU运行阶段1和5，依此类推。彩色块（0到9）代表一系列微批次，其中M是微批次的总数，N是同一阶段前向或后向的连续微批次的数量。我们的关键见解是使N可调。**


**长序列的上下文并行性**。我们利用上下文并行性（CP）在扩展Llama 3的上下文长度时提高内存效率，并启用在长达128K的极长序列上的训练。在CP中，我们跨序列维度进行划分，具体来说，我们将输入序列划分为2 × CP块，以便每个CP等级接收两个块以更好地平衡负载。第i个CP等级接收了第i个和(2 × CP − 1 − i)-th块。

与现有的CP实现不同，后者在环状结构中重叠通信和计算（Liu等人，2023a），我们的CP实现采用了基于all-gather的方法，我们首先all-gather关键（K）和值（V）张量，然后计算局部查询（Q）张量块的注意力输出。尽管all-gather通信延迟在关键路径上暴露出来，但我们仍然采用这种方法，主要有两个原因：(1)在all-gather基础的CP注意力中，支持不同类型的注意力掩码（如文档掩码）更容易、更灵活；(2)由于使用了GQA（Ainslie等人，2023），通信的K和V张量比Q张量小得多，因此暴露的all-gather延迟很小。因此，注意力计算的时间复杂度比all-gather大一个数量级（O(S^2)与O(S)，其中S表示全因果掩码中的序列长度），使all-gather开销微不足道。

**网络感知并行配置**。并行维度的顺序，[TP, CP, PP, DP]，针对网络通信进行了优化。最内层的并行需要最高的网络带宽和最低的延迟，因此通常限制在同一个服务器内。最外层的并行可以跨越多跳网络，并应容忍更高的网络延迟。因此，基于对网络带宽和延迟的要求，我们按照[TP, CP, PP, DP]的顺序放置并行维度。DP（即FSDP）是最外层的并行，因为它可以通过异步预取分片模型权重和减少梯度来容忍更长的网络延迟。在避免GPU内存溢出的同时识别具有最小通信开销的最佳并行配置是具有挑战性的。我们开发了一个内存消耗估计器和性能预测工具，帮助我们探索各种并行配置，并有效地预测整体训练性能和识别内存差距。

**数值稳定性**。通过比较不同并行设置之间的训练损失，我们修复了几个影响训练稳定性的数值问题。为确保训练收敛，我们在多个微批次的后向计算中使用FP32梯度累积，并在FSDP中以FP32跨数据并行工作器减少梯度。对于在前向计算中多次使用的中间张量，例如视觉编码器输出，反向梯度也以FP32累积。

#### 3.3.3 集体通信

我们Llama 3的集体通信库是基于Nvidia的NCCL库的一个分支，称为NCCLX。NCCLX显著提高了NCCL的性能，特别是在高延迟网络上。回想一下，平行维度的顺序是[TP, CP, PP, DP]，其中DP对应于FSDP。最外层的平行维度PP和DP可能通过多跳网络通信，延迟高达数十微秒。原始NCCL集合——FSDP中的all-gather和reduce-scatter，以及PP中的点对点——需要数据分块和分阶段数据复制。这种方法带来了几个效率问题，包括(1)需要在网络上交换大量小控制消息以促进数据传输，(2)额外的内存复制操作，以及(3)使用额外的GPU周期进行通信。对于Llama 3训练，我们通过调整分块和数据传输以适应我们的网络延迟来解决这些效率问题的一个子集，这些延迟对于大型集群可能高达数十微秒。我们还允许小控制消息以更高的优先级在我们的网络上传输，特别是避免在深缓冲核心交换机中被头部阻塞。我们为未来Llama版本进行的持续工作涉及在NCCLX中进行更深入的更改，以全面解决前述所有问题。

#### 3.3.4 可靠性和操作挑战

16K GPU训练的复杂性和潜在故障场景超过了我们运营的规模大得多的CPU集群。此外，训练的同步性质使其对故障的容忍度较低——单个GPU故障可能需要整个作业重新启动。尽管存在这些挑战，对于Llama 3，我们实现了超过90%的有效训练时间，同时支持自动化集群维护，如固件和Linux内核升级（Vigraham和Leonhardi，2024），这导致每天至少有一次训练中断。有效训练时间衡量的是过去时间中用于有用训练的时间。

在预训练的54天快照期间，我们共经历了466次作业中断。其中，47次是计划内的中断，由于自动化维护操作，如固件升级或操作员启动的操作，如配置或数据集更新。其余419次是意外的中断，在表5中进行了分类。约78%的意外中断归因于确认的硬件问题，如GPU或主机组件故障，或疑似与硬件相关的问题，如沉默数据损坏和计划外的单个主机维护事件。GPU问题是最大类别，占所有意外问题的58.7%。尽管失败数量众多，但在此期间仅需要三次重要的手动干预，其余问题由自动化处理。

<a>![](/img/llama3/11.png)</a>
*表5 在Llama 3 405B预训练的54天期间，意外中断的根本原因分类。约78%的意外中断归因于确认或疑似的硬件问题。*

为了增加有效训练时间，我们减少了作业启动和检查点时间，并开发了快速诊断和问题解决工具。我们广泛使用PyTorch内置的NCCL飞行记录器（Ansel等人，2024），这是一个功能，可以捕获集体元数据和堆栈跟踪到环形缓冲区，因此允许我们快速诊断大规模的挂起和性能问题，特别是与NCCLX有关的问题。利用这个，我们有效地记录了每个通信事件和每个集体操作的持续时间，并在NCCLX看门狗或心跳超时时自动转储跟踪数据。我们通过在线配置更改（Tang等人，2015）根据需要在生产中选择性地启用更多计算密集型的跟踪操作和元数据收集，无需代码发布或作业重启。

在我们网络中混合使用NVLink和RoCE使得大规模训练中的问题调试变得复杂。通过NVLink的数据传输通常通过CUDA内核发出的加载/存储操作进行，远程GPU或NVLink连接的故障通常表现为CUDA内核内的加载/存储操作停滞，而没有返回清晰的错误代码。NCCLX通过与PyTorch的紧密共同设计，提高了故障检测和定位的速度和准确性，允许PyTorch访问NCCLX的内部状态并跟踪相关信息。虽然由于NVLink故障引起的停滞无法完全防止，但我们的系统监控通信库的状态，并在检测到此类停滞时自动超时。此外，NCCLX跟踪每个NCCLX通信的内核和网络活动，并提供了失败NCCLX集体内部状态的快照，包括所有等级之间已完成和待定的数据传输。我们分析这些数据来调试NCCLX扩展问题。

有时，硬件问题可能导致仍在运行但速度较慢的落后者，这些落后者很难检测到。即使一个落后者也可以减慢数千其他GPU的速度，通常表现为通信功能正常但速度较慢。我们开发了工具，以优先处理选定进程组中可能存在问题的通信。通过仅调查少数主要嫌疑人，我们通常能够有效地识别落后者。

一个有趣的观察是环境因素对大规模训练性能的影响。对于Llama 3 405B，我们注意到基于一天中时间的日波动1-2%的吞吐量变化。这种波动是由于中午温度较高影响GPU动态电压和频率缩放。在训练期间，成千上万的GPU可能同时增加或减少功耗，例如，由于所有GPU等待检查点或集体通信完成，或整个训练作业的启动或关闭。当这种情况发生时，它可能导致数据中心的功耗瞬间波动数十兆瓦，挑战电网的极限。随着我们为未来更大规模的Llama模型扩展训练，这是我们面临的一个持续挑战。
 
 
### 3.4 训练配方
用于预训练Llama 3 405B的配方包括三个主要阶段：(1) 初始预训练，(2) 长上下文预训练，以及 (3) 退火。下面分别描述这三个阶段。我们使用类似的配方来预训练8B和70B模型。

#### 3.4.1 初始预训练

我们使用余弦学习率计划对Llama 3 405B进行预训练，峰值学习率为$8 \times 10^{-5}$，线性预热8000步，然后在120万训练步骤中衰减到$8 \times 10^{-7}$。我们在训练初期使用较小的批量大小以提高训练稳定性，并随后增加批量大小以提高效率。具体来说，我们最初使用4M令牌的批量大小和长度为4,096的序列，然后在预训练了2.52亿令牌后，将这些值加倍到8M令牌，长度为8,192的序列。我们在预训练了2.87T令牌后再次将批量大小加倍到16M。我们发现这种训练配方非常稳定：我们观察到的损失尖峰很少，并且不需要干预来纠正模型训练发散。

**调整数据混合**。在训练期间，我们对预训练数据混合进行了几次调整，以提高模型在特定下游任务上的性能。特别是，我们增加了非英语数据的百分比，以提高Llama 3的多语言性能。我们还上采样数学数据以提高模型的数学推理性能，我们在预训练的后期增加了更多最新的网络数据以推进模型的知识截止日期，并且我们对后来被识别为质量较低的预训练数据子集进行了下采样。

#### 3.4.2 长上下文预训练

在预训练的最后阶段，我们对长序列进行训练，以支持高达128K令牌的上下文窗口。我们不早点在长序列上训练，因为在自注意力层中的计算在序列长度上呈二次方增长。我们逐步增加支持的上下文长度，预训练直到模型成功适应增加的上下文长度。我们通过测量(1) 模型在短上下文评估上的性能是否完全恢复，以及 (2) 模型是否完美解决了长达该长度的“大海捞针”任务，来评估成功的适应。在Llama 3 405B预训练中，我们从原始的8K上下文窗口开始，逐步增加了六个阶段的上下文长度，最后达到最终的128K上下文窗口。这个阶段的长上下文预训练使用了大约8000亿训练令牌。

#### 3.4.3 退火

在最后4000万个训练令牌的预训练期间，我们线性地将学习率退火到0，同时保持128K令牌的上下文长度。在退火阶段，我们还调整了数据混合，以对非常高质量数据源进行上采样；见第3.1.3节。最后，我们在退火期间计算模型检查点的平均值（Polyak平均值），以产生最终的预训练模型。

## 4 后训练处理

我们通过应用多轮后训练处理，或在预训练检查点的基础上，通过人类反馈（Ouyang等人，2022年；Rafailov等人，2024年）来调整Llama 3模型。每一轮后训练处理包括监督式微调（SFT）和直接偏好优化（DPO；Rafailov等人，2024年），这些优化是在通过人工标注或合成生成的示例上进行的。我们在第4.1节和第4.2节中分别描述了我们的后训练建模和数据方法。我们还在第4.3节中详细说明了定制的数据策划策略，以改进推理、编码、事实性、多语种、工具使用、长文本和精确指令遵循。


### 4.1 建模

我们的后训练策略的核心是奖励模型和语言模型。我们首先使用人类标注的偏好数据（见第 4.1.2 节）在预训练检查点之上训练奖励模型。然后我们通过监督微调（SFT；见第 4.1.3 节）微调预训练的检查点，并通过直接偏好优化（DPO；见第 4.1.4 节）进一步调整检查点。此过程如图 7 所示。除非另有说明，我们的建模过程适用于 Llama 3 405B，为简化起见，我们将 Llama 3 405B 称为 Llama 3。

<a>![](/img/llama3/12.png)</a>
*图7 展示了针对Llama 3的整体后训练方法。我们的后训练策略包括拒绝采样、监督式微调和直接偏好优化。详情见文本。*

#### 4.1.1 聊天对话格式

为了调整 LLMs 进行人机互动，我们需要为模型定义一个聊天对话协议，以便模型理解人类指令并执行对话任务。与其前身相比，Llama 3 具有新的功能，如工具使用（见第 4.3.5 节），这可能需要在单个对话回合内生成多条消息并将其发送到不同位置（例如用户、ipython）。为了支持这一点，我们设计了一个新的多消息聊天协议，该协议使用各种特殊的头标和终止 tokens。头标 tokens 用于指示对话中每条消息的来源和目的地。同样，终止 tokens 指示何时该轮换人类和 AI 说话。

#### 4.1.2 奖励建模

我们在预训练检查点之上训练一个覆盖不同功能的奖励模型（RM）。训练目标与 Llama 2 相同，只是我们删除了损失中的边距项，因为我们观察到数据扩展后改进效果逐渐减弱。按照 Llama 2 的做法，我们在过滤掉具有类似响应的样本后，使用所有偏好数据进行奖励建模。除了标准的（选择的，拒绝的）响应偏好对之外，注释者还为某些提示创建了第三种“编辑响应”，即对偏好对中的选择响应进一步编辑以进行改进（见第 4.2.1 节）。因此，每个偏好排名样本有两个或三个具有明确排名的响应（编辑 > 选择 > 拒绝）。在训练期间，我们将提示和多个响应连接成一行，响应随机打乱。这是将响应放在单独行中并计算分数的标准场景的近似，但在我们的消融实验中，这种方法提高了训练效率而不会降低准确性。

#### 4.1.3 监督微调

然后使用奖励模型对我们的人类标注提示进行拒绝采样，详情见第 4.2 节。结合这些拒绝采样数据和其他数据源（包括合成数据），我们使用标准的交叉熵损失在目标 tokens 上微调预训练语言模型（同时在提示 tokens 上掩蔽损失）。有关数据混合的更多细节见第 4.2 节。我们将这一阶段称为监督微调（SFT；Wei 等，2022a；Sanh 等，2022；Wang 等，2022b），尽管许多训练目标是模型生成的。我们的最大模型在 8.5K 到 9K 步期间以 1e-5 的学习率进行微调。我们发现这些超参数设置在不同轮次和数据混合中效果很好。

#### 4.1.4 直接偏好优化

我们进一步通过直接偏好优化（DPO；Rafailov 等，2024）训练我们的 SFT 模型，以进行人类偏好对齐。对于训练，我们主要使用从前几轮对齐中表现最佳的模型收集的最新偏好数据批次。因此，我们的训练数据更符合每轮优化的策略模型的分布。我们还探索了 PPO（Schulman 等，2017）等政策内算法，但发现 DPO 对大规模模型来说计算需求更少，并且在指令遵循基准测试（如 IFEval；Zhou 等，2023）中表现更好。对于 Llama 3，我们使用 1e-5 的学习率，并将 β 超参数设置为 0.1。此外，我们对 DPO 进行了以下算法修改：

* 在 DPO 损失中屏蔽格式化 tokens：我们在选择和拒绝的响应中屏蔽包括头标和终止 tokens 在内的特殊格式化 tokens，以稳定 DPO 训练。我们观察到，这些 tokens 对损失的贡献可能会导致不希望的模型行为，如尾部重复或突然生成终止 tokens。我们假设这是由于 DPO 损失的对比性质——在选择和拒绝响应中同时存在的共同 tokens 会导致模型需要同时增加和减少这些 tokens 的可能性，从而导致学习目标冲突。
* 用 NLL 损失正则化：我们在选择序列上添加一个额外的负对数似然（NLL）损失项，缩放系数为 0.2，类似于 Pang 等（2024）。这有助于通过保持生成的格式化并防止选择响应的对数概率下降来进一步稳定 DPO 训练（Pang 等，2024；Pal 等，2024）。

#### 4.1.5 模型平均

最后，我们在每个RM、SFT或DPO阶段，使用不同版本的数据或超参数进行实验得到的模型进行平均（Izmailov等人，2019年；Wortsman等人，2022年；Li等人，2022年）。

#### 4.1.6 迭代轮次

遵循Llama 2的做法，我们应用上述方法进行六轮迭代。在每个周期中，我们收集新的偏好标注和SFT数据，从最新模型中采样合成数据。


### 4.2 后训练数据

后训练数据的组成在语言模型的有用性和行为上起着至关重要的作用。在本节中，我们讨论了我们的人工标注程序和偏好数据收集（4.2.1节），SFT数据的组成（4.2.2节），以及数据质量控制和清洗的方法（4.2.3节）。

#### 4.2.1 偏好数据

我们的偏好数据注释过程与Llama 2类似。我们在每一轮后部署多个模型进行注释，并为每个用户提示从两个不同模型中抽取两个响应。这些模型可以采用不同的数据混合和对齐配方进行训练，允许不同的能力强度（例如，编码专业知识）和增加数据多样性。我们要求注释者根据他们对所选响应相对于被拒绝响应的偏好程度，将其分类为四个等级之一：明显更好、更好、略好或稍微更好。我们还在偏好排名后加入一个编辑步骤，鼓励注释者进一步改进首选响应。注释者可以直接编辑所选响应，或者用反馈提示模型以改进自己的响应。因此，我们的偏好数据中有部分有三个响应的排名（编辑 > 选择 > 拒绝）。

<a>![](/img/llama3/13.png)</a>
**表6 人类偏好数据的统计信息。我们列出了用于Llama 3对齐的内部收集的人类偏好数据的统计信息。我们要求注释者与模型进行多轮对话，并在每一轮中对响应进行比较。在后处理中，我们将每个对话拆分为多个在轮次级别的示例。每个示例包括一个提示（如果可用，包括之前的对话）和一个响应（例如，选择或拒绝的响应）。**

在表6中，我们报告了我们用于Llama 3训练的偏好注释的统计信息。通用英语涵盖了多个子类别，如基于知识的问答或精确指令遵循，这些超出了特定能力的范围。与Llama 2相比，我们观察到提示和响应的平均长度有所增加，这表明我们正在训练Llama 3处理更复杂的任务。此外，我们实施了质量分析和人工评估流程，以严格评估收集的数据，使我们能够完善我们的提示并为注释者提供系统化、可操作的反馈。例如，随着Llama 3在每一轮后改进，我们相应地增加提示的复杂性，以针对模型落后的领域。在每一轮后训练，我们使用当时可用的所有偏好数据进行奖励建模，而仅使用各种能力的最新批次进行DPO训练。对于奖励建模和DPO，我们使用标记为所选响应明显更好或比拒绝的对应物更好的样本进行训练，并丢弃响应相似的样本。

#### 4.2.2 SFT数据

我们的微调数据主要由以下来源组成：
* 来自我们人工标注收集的提示，带有拒绝采样的响应
* 针对特定能力的合成数据（详见4.3节）
* 少量人工策划的数据（详见4.3节）

随着我们的后训练轮次的进展，我们开发了更强大的Llama 3变体，我们用它们来收集涵盖广泛复杂能力的更大数据集。在本节中，我们将讨论拒绝采样程序的细节和我们最终SFT数据混合的总体组成。

**拒绝采样**。在拒绝采样（RS）期间，对于在人工标注中收集的每个提示（4.2.1节），我们从最新的聊天模型策略中采样K（通常在10到30之间）个输出（通常是上一次后训练迭代中表现最佳的检查点，或者是特定能力的最优秀检查点），并使用我们的奖励模型选择最佳候选，这与Bai等人（2022年）的方法一致。在后训练的后期轮次中，我们引入系统提示，引导RS响应符合期望的语调、风格或格式，这些可能因不同能力而异。

为了提高拒绝采样的效率，我们采用了PagedAttention（Kwon等人，2023年）。PagedAttention通过动态键值缓存分配增强了内存效率。它通过根据当前缓存容量动态调度请求来支持任意输出长度。不幸的是，这在内存不足时会带来交换开销的风险。为了消除这种交换开销，我们定义了最大输出长度，并仅在有足够的内存来容纳该长度的输出时才执行请求。PagedAttention还使我们能够跨所有相应的输出共享提示的键值缓存页面。这共同导致了拒绝采样期间吞吐量的2倍以上的提高。

**总体数据组成**。表7显示了我们“有用性”混合中每个广泛类别的数据统计信息。虽然SFT和偏好数据包含重叠的领域，但它们以不同的方式策划，产生了不同的计数统计数据。在4.2.3节中，我们将描述对我们的数据样本进行主题、复杂性和质量分类的技术。在每一轮后训练，我们仔细调整我们的整体数据混合，以调整在广泛基准测试中的性能。我们最终的数据混合在一些高质量资源上多次循环，并对其他资源进行下采样。

<a>![](/img/llama3/14.png)</a>
**表7 SFT数据的统计信息。我们列出了用于Llama 3对齐的内部收集的SFT数据。每个SFT示例由一个上下文（即，除最后一个之外的所有对话轮次）和一个最终响应组成。**


#### 4.2.3 数据处理和质量控制

鉴于我们的大部分训练数据是模型生成的，因此需要仔细清洗和质量控制。

**数据清洗**。在早期轮次中，我们观察到数据中存在一些不希望出现的模式，例如过度使用表情符号或感叹号。因此，我们实施了一系列基于规则的数据移除和修改策略，以过滤或清理有问题的数据。例如，为了减轻过于道歉的语调问题，我们识别过度使用的短语（如“I’m sorry”或“I apologize”），并仔细平衡这些样本在我们数据集中的比例。

**数据修剪**。我们还应用一系列基于模型的技术来移除低质量的训练样本并提高整体模型性能：

* 主题分类：我们首先将Llama 3 8B微调为一个主题分类器，并在所有数据上进行推断，将其分类为粗粒度的桶（“数学推理”）和细粒度的桶（“几何和三角学”）。
* 质量评分：我们使用奖励模型和基于Llama的信号为每个样本获得一个质量分数。对于基于RM的分数，我们认为在RM分数中处于上四分位数的数据为高质量。对于基于Llama的分数，我们提示Llama 3检查点对每个样本在一般英语数据上进行三点量表评分（准确性、指令遵循和语调/展示）以及对编码数据进行两点量表评分（错误识别和用户意图），并认为获得最高分数的样本为高质量。RM和基于Llama的分数有很高的不一致率，我们发现结合这些信号在我们的内部测试集上获得最佳召回率。最终，我们选择被RM或基于Llama的过滤器标记为高质量的示例。
* 难度评分：因为我们也对优先考虑对模型更复杂的示例感兴趣，我们使用两个难度度量对数据进行评分：Instag（Lu等人，2023年）和基于Llama的评分。对于Instag，我们提示Llama 3 70B对SFT提示进行意图标记，其中更多的意图意味着更复杂。我们还提示Llama 3在三点量表上测量对话的难度（Liu等人，2024年c）。
* 语义去重：最后，我们执行语义去重（Abbas等人，2023年；Liu等人，2024年c）。我们首先使用RoBERTa（Liu等人，2019b）对完整对话进行聚类，并在每个聚类内按质量分数×难度分数排序。然后我们通过迭代所有排序的示例，进行贪婪选择，并只保留那些与聚类中到目前为止看到的示例的最大余弦相似度小于阈值的示例。

### 4.3 能力

我们特别强调为提高特定能力的性能所做的努力，例如代码（4.3.1节）、多语言（4.3.2节）、数学和推理（4.3.3节）、长文本（4.3.4节）、工具使用（4.3.5节）、事实性（4.3.6节）和可引导性（4.3.7节）。

#### 4.3.1 代码

自从Copilot和Codex（Chen等人，2021年）发布以来，用于代码的大型语言模型（LLMs）受到了广泛关注。开发者现在广泛使用这些模型来生成代码片段、调试、自动化任务和提高代码质量。对于Llama 3，我们的目标是提高以下高优先级编程语言的代码生成、文档编写、调试和审查能力：Python、Java、Javascript、C/C++、Typescript、Rust、PHP、HTML/CSS、SQL、bash/shell。在这里，我们展示了通过训练代码专家、为SFT生成合成数据、通过系统提示引导改进格式化以及创建质量过滤器从我们的训练数据中移除不良样本来提高这些编码能力的工作。

**专家训练**。我们训练了一个代码专家，我们用它在随后的训练轮次中收集高质量的代码人工标注。这是通过分支主预训练运行并在主要是（>85%）代码数据的1T令牌混合上继续预训练来实现的。继续在特定领域的数据上进行预训练已被证明对提高特定领域的性能有效（Gururangan等人，2020年）。我们遵循与CodeLlama（Rozière等人，2023年）类似的配方。在训练的最后几千步中，我们执行长文本微调（LCFT）以将专家的上下文长度扩展到16K令牌的高质量混合存储库级代码数据。最后，我们遵循4.1节中描述的类似的后训练建模配方来对齐这个模型，只是SFT和DPO数据混合主要针对代码。这个模型也用于代码提示的拒绝采样（4.2.2节）。

**合成数据生成**。在开发过程中，我们确定了代码生成中的一些关键问题，包括难以遵循指令、代码语法错误、错误的代码生成以及难以修复错误。虽然理论上密集的人工标注可以解决这些问题，但合成数据生成提供了一种成本更低、规模更大、不受注释者专业水平限制的补充方法。因此，我们使用Llama 3和代码专家生成了大量合成SFT对话。

我们描述了生成合成代码数据的三种高层方法。总共，我们生成了超过270万个合成示例，这些示例在SFT中使用。

**1.合成数据生成：执行反馈**。8B和70B模型在训练时使用更大、更有能力模型生成的数据时显示出显著的性能提升。然而，我们最初的实验表明，训练Llama 3 405B使用自己生成的数据是没有帮助的（甚至可能降低性能）。为了解决这个限制，我们引入执行反馈作为真实来源，使模型能够从错误中学习并保持在正确的轨道上。特别是，我们使用以下流程生成了大约一百万个合成编码对话的大型数据集：

* 问题描述生成：首先，我们生成了大量涵盖多样化主题的编程问题描述，包括长尾分布中的主题。为了实现这种多样性，我们从各种来源随机采样代码片段，并提示模型根据这些示例生成编程问题。这使我们能够利用广泛的主题，并创建一套全面的问题描述（Wei等人，2024年）。

* 解决方案生成：然后，我们提示Llama 3用给定的编程语言解决每个问题。我们观察到，在提示中添加通用的良好编程规则可以提高生成的解决方案质量。此外，我们发现要求模型在注释中解释其思维过程也是有帮助的。

* 正确性分析：生成解决方案后，至关重要的是要认识到其正确性并不是保证的，将不正确的解决方案包括在微调数据集中可能会损害模型的质量。虽然我们不保证完全正确，但我们开发了近似它的方法。为此，我们从生成的解决方案中提取源代码，并应用了静态和动态分析技术的组合来测试其正确性，包括：
    * 静态分析：我们将所有生成的代码通过解析器和linter运行，以确保语法正确性，捕捉诸如语法错误、使用未初始化的变量或未导入的函数、代码风格问题、类型错误等错误。
    * 单元测试生成和执行：对于每个问题和解决方案，我们提示模型生成单元测试，在容器化环境中与解决方案一起执行，捕捉运行时执行错误和一些语义错误。
    
* 错误反馈和迭代自我纠正：当解决方案在任何步骤失败时，我们提示模型进行修订。提示包括原始问题描述、有缺陷的解决方案以及来自解析器/linter/测试器的反馈（stdout、stderr和返回代码）。在单元测试执行失败后，模型可以修复代码以通过现有测试，或者修改其单元测试以适应生成的代码。只有通过所有检查的对话才包含在最终数据集中，用于监督式微调（SFT）。值得注意的是，我们观察到大约20%的解决方案最初是不正确的，但自我纠正了，这表明模型从执行反馈中学习并提高了其性能。

- 微调和迭代改进：微调过程经过多轮进行，每一轮都建立在前一轮的基础上。在每一轮之后，模型都会得到改进，为下一轮生成更高质量的合成数据。这个迭代过程允许逐步细化和增强模型的性能。

**2.合成数据生成：编程语言翻译**。我们观察到主要编程语言（例如，Python/C++）和不太常见的语言（例如，Typescript/PHP）之间的性能差距。这并不奇怪，因为我们对不太常见的编程语言的训练数据较少。为了缓解这个问题，我们通过将常见编程语言的数据翻译成不太常见的语言来补充我们现有的数据（类似于Chen等人（2023年）在推理背景下的做法）。这是通过提示Llama 3并确保通过语法解析、编译和执行来保证质量来实现的。图8展示了一个从Python翻译成PHP的合成代码示例。这显著提高了不太常见语言的性能，如MultiPL-E（Cassano等人，2023年）基准测试所测量的。

<a>![](/img/llama3/15.png)</a>
**图8 代码翻译示例。我们展示了使用Llama 3将Python代码（左侧）翻译成PHP代码（右侧）的例子，以增加我们的SFT数据集包含更广泛的编程语言。**

**3.合成数据生成：回译**。为了提高某些编码能力（例如，文档编写、解释）的性能，其中执行反馈对于确定质量的有用性较低，我们采用了一种替代的多步骤方法。使用这种方法，我们生成了大约120万个与代码解释、生成、文档编写和调试相关的合成对话。从我们的预训练数据中以各种语言编写的代码片段开始：

* 生成：我们提示Llama 3生成代表我们目标能力的数据（例如，我们为代码片段添加注释和文档字符串，或者我们要求模型解释一段代码）。
* 回译：然后，我们提示模型将合成生成的数据“回译”到原始代码（例如，我们提示模型仅根据其文档生成代码，或者我们要求模型仅根据其解释生成代码）。
* 过滤：使用原始代码作为参考，我们提示Llama 3确定输出的质量（例如，我们问模型回译的代码与原始代码的忠实度如何）。然后我们在SFT中使用具有最高自我验证分数的生成示例。

**拒绝采样过程中的系统提示引导**。在拒绝采样过程中，我们使用特定于代码的系统提示来提高代码的可读性、文档编写、彻底性和特异性。回想一下，第7节中的数据用于微调语言模型。图9展示了一个系统提示如何帮助提高生成的代码质量的示例——它添加了必要的注释，使用了更信息丰富的变量名，节省了内存等。

<a>![](/img/llama3/16.png)</a>
*图9 使用系统提示提高生成代码的质量。左侧：没有使用系统提示 右侧：使用了系统提示。*


**使用执行和模型作为裁判信号过滤训练数据**。如4.2.3节所述，我们偶尔在我们的拒绝采样数据中遇到质量问题，例如包含错误的代码块。在我们的拒绝采样数据中检测这些问题并不像在我们的合成代码数据中那样直接，因为拒绝采样的响应通常包含自然语言和代码的混合，而代码可能并不总是预期为可执行的。（例如，用户提示可能明确要求伪代码或仅对可执行程序的非常小的片段进行编辑。）为了解决这个问题，我们采用了“模型作为裁判”的方法，早期版本的Llama 3根据两个标准评估并分配一个二进制（0/1）分数：代码正确性和代码风格。我们只保留那些获得2分完美分数的样本。最初，这种严格的过滤导致了下游基准性能的回归，主要是因为它不成比例地移除了具有挑战性的提示的示例。为了抵消这一点，我们有策略地修订了一些被归类为最具挑战性的编码数据的响应，直到它们满足基于Llama的“模型作为裁判”的标准。通过完善这些具有挑战性的问题，编码数据在质量和难度之间实现了平衡，从而实现了最佳的下游性能。



#### 4.3.2 多语言性

我们描述了如何提高Llama 3的多语言能力，包括训练一个专门处理更多多语言数据的专家、为德语、法语、意大利语、葡萄牙语、印地语、西班牙语和泰语收集和生成高质量的多语言指令调整数据，以及应对多语言语言引导的具体挑战，以提高我们模型的整体性能。

**专家训练**。我们的Llama 3预训练数据混合包含了明显多于非英语令牌的英语令牌。为了收集非英语语言中更高质量的人工标注，我们通过分支预训练运行并在由90%多语言令牌组成的数据混合上继续预训练来训练一个多语言专家。然后，我们按照4.1节对这位专家进行后训练的调整。这个专家模型随后被用来在非英语语言中收集更高质量的注释，直到预训练完全完成。

**多语言数据收集**。我们的多语言SFT数据主要来源于以下描述的来源。总体分布是2.4%的人工标注，44.2%来自其他NLP任务的数据，18.8%的拒绝采样数据，和34.6%的翻译推理数据。

* 人工标注：我们从语言学家和母语者那里收集高质量的、人工标注的数据。这些注释主要由代表现实世界用例的开放式提示组成。
* 来自其他NLP任务的数据：为了进一步增强，我们使用来自其他任务的多语言训练数据，并将其改写成对话格式。例如，我们使用来自exams-qa（Hardalov等人，2020年）和Conic10k（Wu等人，2023年）的数据。为了提高语言对齐，我们还使用来自GlobalVoices（Prokopidis等人，2016年）和Wikimedia（Tiedemann，2012年）的平行文本。我们使用基于LID的过滤和Blaser2.0（Seamless Communication等人，2023年）来移除低质量数据。对于平行文本数据，我们不是直接使用双语文本对，而是应用了受Wei等人（2022a）启发的多语言模板，以更好地模拟翻译和语言学习场景中的真实生活对话。
* 拒绝采样数据：我们在人工标注的提示上应用拒绝采样来生成用于微调的高质量样本，与英语数据的过程相比只有少量修改：
    * 生成：在后训练的早期轮次中，我们探索了在0.2−1范围内随机选择温度超参数，以实现多样化的生成。高温下，多语言提示的响应可以变得创造性和鼓舞人心，但也容易受到不必要或不自然的代码转换的影响。在后训练的最后轮次中，我们使用恒定的0.6值来平衡权衡。此外，我们还使用专门的系统提示来改进响应的格式、结构和总体可读性。
    * 选择：在基于奖励模型的选择之前，我们实施了特定于多语言的检查，以确保提示和响应之间的高语言匹配率（例如，罗马化的印地语提示不应期望以印地语天城文脚本回应）。
* 翻译数据：我们尽量避免使用机器翻译的数据来微调模型，以防止翻译腔（Bizzoni等人，2020年；Muennighoff等人，2023年）或可能的名称偏见（Wang等人，2022a年）、性别偏见（Savoldi等人，2021年）或文化偏见（Ji等人，2023年）。此外，我们旨在防止模型只暴露于植根于英语文化背景的任务中，这可能无法代表我们旨在捕捉的语言和文化多样性。我们对此有一个例外，并将我们的合成定量推理数据（见4.3.3节详情）翻译成非英语语言，以提高非英语语言中的定量推理能力。由于这些数学问题的语言性质简单，翻译样本的质量几乎没有问题。我们观察到，通过添加这些翻译数据，在MGSM（Shi等人，2022年）上取得了强劲的增长。


#### 4.3.3 数学和推理

我们将推理定义为执行多步骤计算并得出正确最终答案的能力。几个挑战指导我们训练在数学推理方面表现出色的模型的方法：

* 缺乏提示：随着问题的复杂性增加，用于监督式微调（SFT）的有效提示或问题数量减少。这种稀缺性使得为教授模型各种数学技能创建多样化和具有代表性的训练数据集变得困难（Yu等人，2023年；Yue等人，2023年；Luo等人，2023年；Mitra等人，2024年；Shao等人，2024年；Yue等人，2024b年）。
* 缺乏真实思考过程链：有效的推理需要逐步解决方案以促进推理过程（Wei等人，2022c年）。然而，通常缺少真实思考过程链，这对于指导模型如何一步步分解问题并得出最终答案至关重要（Zelikman等人，2022年）。
* 中间步骤可能不正确：当使用模型生成的思考过程链时，中间步骤可能并不总是正确的（Cobbe等人，2021年；Uesato等人，2022年；Lightman等人，2023年；Wang等人，2023a年）。这种不准确性可能导致最终答案不正确，需要解决。
* 教授模型使用外部工具：增强模型以利用外部工具，如代码解释器，允许它们通过交错代码和文本进行推理（Gao等人，2023年；Chen等人，2022年；Gou等人，2023年）。这种能力可以显著提高它们的解决问题能力。
* 训练和推理之间的差异：训练期间模型的微调方式与推理期间的使用方式之间通常存在差异。在推理期间，微调模型可能与人类或其他模型交互，要求它使用反馈改进其推理。确保训练和真实世界使用之间的一致性对于维持推理性能至关重要。

为了应对这些挑战，我们应用了以下方法：

* 解决提示缺乏问题：我们从数学背景中获取相关的预训练数据，并将其转换为问答格式，然后可用于监督式微调。此外，我们确定模型表现不佳的数学技能，并积极从人类那里获取提示，以教授模型这些技能。为了促进这个过程，我们创建了一个数学技能分类（Didolkar等人，2024年），并要求人类相应地提供相关的提示/问题。
* 用逐步推理痕迹增强训练数据：我们使用Llama 3为一组提示生成逐步解决方案。对于每个提示，模型产生不同数量的生成。然后根据正确答案过滤这些生成（Li等人，2024a年）。我们还进行自我验证，使用Llama 3验证特定的逐步解决方案是否适用于给定问题。这个过程通过消除模型未产生有效推理痕迹的实例，提高了微调数据的质量。
* 过滤不正确的推理痕迹：我们训练结果和逐步奖励模型（Lightman等人，2023年；Wang等人，2023a年）来过滤训练数据，其中中间推理步骤是不正确的。这些奖励模型用于消除具有无效逐步推理的数据，确保微调的高质量数据。对于更具挑战性的提示，我们使用带有学习逐步奖励模型的蒙特卡洛树搜索（MCTS）生成有效的推理痕迹，进一步提高了收集高质量推理数据的能力（Xie等人，2024年）。
* 交错代码和文本推理：我们提示Llama 3通过文本推理和相关Python代码的组合来解决推理问题（Gou等人，2023年）。代码执行被用作反馈信号，以消除推理链无效的情况，确保推理过程的正确性。
* 从反馈和错误中学习：为了模拟人类反馈，我们利用不正确的生成（即导致不正确推理痕迹的生成）并通过提示Llama 3产生正确的生成来进行错误纠正（An等人，2023b年；Welleck等人，2022年；Madaan等人，2024a年）。使用来自不正确尝试的反馈并纠正它们的迭代过程有助于提高模型准确推理并从错误中学习的能力。

#### 4.3.4 长文本

在最后的预训练阶段，我们将Llama 3的上下文长度从8K令牌扩展到128K令牌（有关更多详细信息，请参阅第3.4节）。与预训练类似，我们发现在微调过程中，我们必须仔细调整配方，以平衡短文本和长文本能力。

**SFT和合成数据生成**。简单地应用我们现有的仅使用短文本数据的SFT配方，导致长文本能力相比预训练出现了显著的退步，这突显了在我们的SFT数据混合中纳入长文本数据的必要性。然而，在实践中，由于阅读长文本的乏味和耗时，让人类注释这类示例在很大程度上是不切实际的，因此我们主要依赖合成数据来填补这一空白。我们使用早期版本的Llama 3根据关键的长文本用例生成合成数据：（可能是多轮的）问答、长文档的摘要以及对代码库的推理，我们将在下面更详细地描述它们。

* 问答：我们从预训练混合中精心策划了一系列长文档。我们将这些文档分割成8K令牌的块，并提示早期版本的Llama 3模型根据随机选择的块生成QA对。在训练过程中，整个文档被用作上下文。

* 摘要：我们通过对长文本文档进行分层摘要来应用长文本摘要，首先使用我们最强的Llama 3 8K上下文模型对8K输入长度的块进行摘要，然后对摘要进行摘要。在训练中，我们提供完整文档，并提示模型在保留所有重要细节的同时对文档进行摘要。我们还根据文档的摘要生成QA对，并用需要对整个长文档全局理解的问题提示模型。

* 长文本代码推理：我们解析Python文件以识别import语句并确定它们的依赖关系。从这里，我们选择最常依赖的文件，特别是至少被其他五个文件引用的文件。我们从一个代码库中移除其中一个关键文件，并提示模型识别哪些文件依赖于缺失的文件，并生成必要的缺失代码。

我们根据序列长度（16K、32K、64K和128K）进一步对这些合成生成的样本进行分类，以便更精细地定位输入长度。

通过仔细的消融研究，我们观察到将0.1%的合成生成的长文本数据与原始短文本数据混合，可以在短文本和长文本基准测试中优化性能。

**DPO**。我们观察到，只要SFT模型适合长文本任务，仅使用短文本训练数据在DPO中就不会对长文本性能产生负面影响。我们怀疑这是由于我们的DPO配方比SFT拥有更少的优化步骤。鉴于这一发现，我们在长文本SFT检查点上保持DPO的标准短文本配方。


#### 4.3.5 工具使用

教会大型语言模型（LLMs）使用工具，如搜索引擎或代码解释器，极大地扩展了它们能够解决的任务范围，将它们从纯聊天模型转变为更通用的助手（Nakano等人，2021年；Thoppilan等人，2022年；Parisi等人，2022年；Gao等人，2023年；Mialon等人，2023a年；Schick等人，2024年）。我们训练Llama 3与以下工具进行交互：

* 搜索引擎。Llama 3被训练使用Brave Search来回答问题，这些答案超出了它的知识截止日期，或者需要从网络检索特定信息。
* Python解释器。Llama 3可以生成并执行代码以执行复杂计算、读取用户上传的文件，并根据这些文件解决任务，如问答、摘要、数据分析或可视化。
* 数学计算引擎。Llama 3可以使用Wolfram Alpha API来更准确地解决数学、科学问题，或从Wolfram的数据库检索准确信息。

所得到的模型能够在聊天设置中使用这些工具来解决用户的查询，包括在多轮对话中。如果查询需要多次调用工具，模型可以编写逐步计划，按顺序调用工具，并在每次工具调用后进行推理。

我们还提高了Llama 3的零样本工具使用能力——在给定上下文中，可能未见过的工具定义和用户查询，我们训练模型生成正确的工具调用。

**实现**。我们将核心工具实现为具有不同方法的Python对象。零样本工具可以作为具有描述、文档（即，如何使用它们的示例）的Python函数实现，模型只需要函数的签名和文档字符串作为上下文来生成适当的调用。我们还将函数定义和调用转换为JSON格式，例如，用于Web API调用。所有工具调用都由Python解释器执行，该解释器必须在Llama 3系统提示中启用。核心工具可以在系统提示中单独启用或禁用。

**数据收集**。与Schick等人（2024年）不同，我们依赖人工标注和偏好来教会Llama 3使用工具。与通常在Llama 3中使用的后训练流程有两个主要区别：

* 对于工具，对话通常包含多个助手消息（例如，调用工具并推理工具输出）。因此，我们在消息级别进行注释以收集细粒度反馈：注释者在两个具有相同上下文的助手消息之间提供偏好，或者，如果两个都包含重大问题，则编辑其中之一。选择或编辑的消息然后被添加到上下文中，对话继续。这为助手调用工具的能力和对工具输出的推理提供了人工反馈。注释者不能对工具输出进行排名或编辑。
* 我们不执行拒绝采样，因为我们没有在我们的工具基准测试中观察到增益。

为了加速注释过程，我们首先通过在以前Llama 3检查点生成的合成数据上进行微调，引导基本工具使用能力。因此，注释者需要进行的编辑较少。同样，随着Llama 3在开发过程中逐渐改进，我们逐步复杂化我们的人工标注协议：我们从单轮工具使用注释开始，然后转向对话中的工具使用，最后注释多步工具使用和数据分析。

**工具数据集**。为了为工具使用应用创建数据，我们利用以下程序：

* 单步工具使用：我们首先通过少量生成的合成用户提示开始，这些提示在构建时就需要调用我们的核心工具之一（例如，超出我们知识截止日期的问题）。然后，仍然依赖少量生成，我们为这些提示生成适当的工具调用，执行它们，并将输出添加到模型的上下文中。最后，我们再次提示模型根据工具输出生成对用户查询的最终答案。我们最终得到以下形式的轨迹：系统提示、用户提示、工具调用、工具输出、最终答案。我们还筛选了约30%的数据集，以移除无法执行的工具调用或其他格式问题。
* 多步工具使用：我们遵循类似的协议，首先生成合成数据以教授模型基本的多步工具使用能力。为此，我们首先提示Llama 3生成至少需要两次工具调用的用户提示，这些可以是相同或不同的核心工具。然后，根据这些提示，我们少量提示Llama 3生成一个解决方案，包括交错的推理步骤和工具调用，类似于ReAct（Yao等人，2022年）。见图10，展示了Llama 3执行涉及多步工具使用的任务的示例。
* 文件上传：我们注释以下文件类型：.txt、.docx、.pdf、.pptx、.xlsx、.csv、.tsv、.py、.json、.jsonl、.html、.xml。我们的提示基于提供的文件，并要求摘要文件内容，查找和修复错误，优化代码片段，执行数据分析或可视化。见图11，展示了Llama 3执行涉及文件上传的任务的示例。

<a>![](/img/llama3/17.png)</a>
*图10 多步工具使用。Llama 3执行多步规划、推理和调用工具来解决任务的示例。*

<a>![](/img/llama3/18.png)</a>
*图11 图11 处理文件上传。Llama 3对上传文件进行分析和可视化的示例。*

在对这个合成数据进行微调后，我们在包括多轮交互、超过三步工具使用，以及工具调用没有得到满意答案的多样化和具有挑战性的场景中收集人工标注。我们通过不同的系统提示增强我们的合成数据，以教会模型仅在激活时使用工具。为了防止模型对简单查询调用工具，我们还添加了来自简单数学或问答数据集（Berant等人，2013年；Koncel-Kedziorski等人，2016年；Joshi等人，2017年；Amini等人，2019年）的查询及其响应，但没有工具，但在系统提示中启用了工具。

**零样本工具使用数据**。我们通过在大量多样的部分合成数据集（函数定义、用户查询、相应的调用）上进行微调，提高了Llama 3的零样本工具使用能力（也称为函数调用）。我们在一组未见过的工具上评估我们的模型。

* 单个、嵌套和并行函数调用：调用可以是简单的，嵌套的，即我们把一个函数调用作为另一个函数的参数传递，或者是并行的，即模型返回一系列独立的函数调用。生成多样化的函数、查询和真实情况可能具有挑战性（Mekala等人，2024年），我们依靠挖掘Stack（Kocetkov等人，2022年）来使我们的合成用户查询基于真实函数。更具体地说，我们提取函数调用及其定义，进行清理和过滤，例如缺少文档字符串或不可执行的函数，并使用Llama 3生成与函数调用相对应的自然语言查询。

* 多轮函数调用：我们还为带有函数调用的多轮对话生成合成数据，遵循Li等人（2023b年）提出的协议。我们使用多个代理生成领域、API、用户查询、API调用和响应，同时确保生成的数据涵盖多样化的领域和现实的API。所有代理都是以不同方式提示的Llama 3的变体，根据它们的角色进行协作，并以逐步的方式进行协作。


#### 4.3.6 事实性

幻觉仍然是大型语言模型面临的一个主要挑战。模型往往过于自信，即使在它们知之甚少的领域也是如此。尽管存在这些缺陷，它们通常仍被用作知识库，这可能导致诸如错误信息传播等危险结果。虽然我们认识到事实性可以超越幻觉，但在这里我们采取了以幻觉为先的方法。我们遵循的原则是，训练后应该使模型“知道它所知道的”，而不是增加知识（Gekhman等人，2024年；Mielke等人，2020年）。我们的主要方法包括生成数据，使模型生成与预训练数据中呈现的事实数据子集一致。为了实现这一点，我们开发了一种利用Llama 3上下文能力的知识探测技术。这个数据生成过程包括以下步骤：

* 1.从预训练数据中提取数据片段。
* 2.通过提示Llama 3，基于这些片段（上下文）生成一个事实性问题。
* 3.从Llama 3对问题进行采样响应。
* 4.使用原始上下文作为参考，以Llama 3为裁判，对生成的正确性进行评分。
* 5.使用Llama 3为裁判，对生成的信息量进行评分。
* 6.对于在生成中一贯信息量大但不正确的响应，使用Llama 3生成拒绝回答。

我们使用从知识探测生成的数据，鼓励模型只回答它所知道的问题，并拒绝回答那些它不确定的问题。此外，预训练数据并不总是事实一致或正确的。因此，我们还收集了有限的标记事实性数据集，这些数据涉及存在事实矛盾或错误陈述的敏感话题。


#### 4.3.7 可引导性

可引导性是将模型的行动和结果引导至满足开发者和用户规范的能力。由于Llama 3是一个通用的基础模型，它应该能够轻松地被引导至不同的下游用例。对于Llama 3，我们专注于通过自然语言指令的系统提示来增强其可引导性，尤其是在响应长度、格式、语调和角色/个性方面。

**数据收集**。我们通过要求注释者为Llama 3设计不同的系统提示，在普通英语类别中收集可引导性偏好样本。然后，注释者与模型进行对话，评估它们在对话过程中遵循系统提示中定义的指令的一致性。我们在下面展示了一个用于增强可引导性的定制系统提示示例：

<a>![](/img/llama3/19.png)</a>

**建模**。在我们收集了偏好数据后，我们利用这些数据在奖励建模、拒绝采样、SFT（监督式微调）和DPO（直接偏好优化）中，以增强Llama 3的可引导性。

## 5 结果

跳过，请阅读论文。

## 6 推理
我们研究了两种主要技术来使Llama 3 405B模型的推理过程高效：（1）流水线并行性；（2）FP8量化。我们已经公开发布了我们的FP8量化实现。

### 6.1 流水线并行性

当使用BF16数字表示模型参数时，Llama 3 405B不适合单台机器上的8个Nvidia H100 GPU的GPU内存。为了解决这个问题，我们在两台机器上的16个GPU上使用BF16精度进行模型推理并行化。在每台机器内，高NVLink带宽使得可以使用张量并行性（Shoeybi等人，2019）。然而，在节点之间，连接带宽较低且延迟较高，因此我们使用流水线并行性（Huang等人，2019）。

在使用流水线并行性进行训练时，气泡是主要的效率问题（见第3.3节）。然而，在推理期间它们不是问题，因为推理不涉及需要流水线冲洗的反向传递。因此，我们使用微批处理来提高流水线并行推理的吞吐量。

我们评估了在推理工作负载中使用两个微批处理的影响，输入令牌为4,096，输出令牌为256，分别在推理的键值缓存预填充阶段和解码阶段。我们发现微批处理提高了相同本地批量大小的推理吞吐量；见图24。这些改进来自于微批处理在这两个阶段使微批处理能够并发执行。

<a>![](/img/llama3/20.png)</a>
*图24 微批处理对推理吞吐量和延迟的影响，在左侧：预填充阶段和右侧：解码阶段。图中的数字对应于（微）批量大小。*


由于微批处理而增加的额外同步点也增加了延迟，但总体上，微批处理仍然导致了更好的吞吐量-延迟权衡。

### 6.2 FP8量化

我们利用H100 GPU对FP8的原生支持进行低精度推理实验。为了实现低精度推理，我们对模型内的大多数矩阵乘法应用FP8量化。特别是，我们量化了模型中前馈网络层中的大多数参数和激活，这些层大约占推理计算时间的50%。我们没有量化模型自注意力层的参数。我们利用动态缩放因子来提高准确性（Xiao等人，2024b），优化我们的CUDA内核以减少计算比例的开销。我们发现Llama 3 405B的质量对某些类型的量化很敏感，并进行了一些额外的更改以提高模型输出质量：

* 1.与Zhang等人（2021）类似，我们不在第一层和最后一层Transformer层进行量化。
* 2.高困惑度的令牌，如日期，可能导致大的激活值。反过来，这可能导致FP8中的高动态缩放因子和不可忽略数量的下溢，导致解码错误。
   为了解决这个问题，我们将动态缩放因子上限定为1200。
* 3.我们使用按行量化，为参数和激活矩阵计算跨行的缩放因子（见图25）。我们发现这种方法比按张量量化的方法更有效。


<a>![](/img/llama3/21.png)</a>
*图25 展示了张量级和按行FP8量化的示意图。右侧：按行量化允许使用比左侧：张量级量化更细粒度的激活因子。*

**量化误差的影响**。标准基准测试通常表明，即使没有这些缓解措施，FP8推理的性能也与BF16推理相当。然而，我们发现这样的基准测试并没有充分反映FP8量化的影响。当缩放因子没有上界时，模型偶尔会产生损坏的响应，尽管基准性能很强。我们发现，与其依赖基准测试来衡量量化引起的分布变化，不如分析使用FP8和BF16产生的100,000个响应的奖励模型分数的分布。图26显示了我们的量化方法的奖励分布结果。图中的结果显示，我们的FP8量化方法对模型的响应影响非常有限。

<a>![](/img/llama3/22.png)</a>
*图26 Llama 3 405B使用BF16和FP8推理的奖励分数分布。我们的FP8量化方法对模型的响应几乎没有影响。*


**效率的实验评估**。图27描绘了在预填充和解码阶段使用Llama 3 405B进行FP8推理的吞吐量-延迟权衡，输入令牌为4,096，输出令牌为256。该图比较了第6.1节中描述的两台机器BF16推理方法的效率。结果表明，使用FP8推理在预填充阶段的吞吐量提高了高达50%，在解码阶段的吞吐量-延迟权衡明显更好。

<a>![](/img/llama3/23.png)</a>
**图27 使用Llama 3 405B进行FP8推理与使用不同流水线并行设置的BF16推理的吞吐量-延迟权衡。左侧：预填充的结果。右侧：解码的结果。**


## 7 视觉实验

我们进行了一系列实验，通过一种由两个主要阶段组成的组合方法将视觉识别能力整合到Llama 3中。首先，我们通过在两个模型之间引入和训练一组交叉注意力层（Alayrac等人，2022），将预训练的图像编码器（Xu等人，2023）和预训练的语言模型组合起来，用于大量图像-文本对。这导致形成了图28所示的模型。其次，我们引入了时间聚合层和额外的视频交叉注意力层，这些层在大量视频-文本对上操作，以学习模型识别和处理视频中的时间信息。

<a>![](/img/llama3/24.png)</a>
**图28 本文研究的向Llama 3添加多模态能力的组合方法的示意图。这种方法导致了一个经过五个阶段训练的多模态模型：（1）语言模型预训练，（2）多模态编码器预训练，（3）视觉适配器训练，（4）模型微调，以及（5）语音适配器训练。**

采用组合方法进行基础模型开发有几个优点：（1）它使我们能够并行开发视觉和语言建模能力；（2）它避免了视觉和语言数据联合预训练的复杂性，这些复杂性源于视觉数据的标记化、来自不同模态的标记的背景困惑度差异以及模态之间的竞争；（3）它保证了模型在仅文本任务上的性能不会因引入视觉识别能力而受到影响，并且（4）交叉注意力架构确保我们不需要通过越来越多的LLM骨干（特别是每个transformer层中的前馈网络）传递全分辨率图像，使推理过程更加高效。我们注意到我们的多模态模型仍在开发中，尚未准备好发布。

在第7.6节和7.7节中介绍我们的实验结果之前，我们描述了我们用于训练视觉识别能力的数据，视觉组件的模型架构，我们如何扩展这些组件的训练，以及我们的预训练和后训练配方。

### 7.1 数据

我们分别描述了我们的图像和视频数据。

#### 7.1.1 图像数据

我们的图像编码器和适配器在图像-文本对上进行训练。我们通过一个复杂的数据处理流程构建这个数据集，该流程包括四个主要阶段：（1）质量过滤，（2）感知去重，（3）重新采样，和（4）光学字符识别。我们还应用了一系列安全缓解措施。

* 质量过滤。我们实施了质量过滤器，通过（Radford等人，2021）产生的低对齐分数等启发式方法去除非英语字幕和低质量字幕。具体来说，我们删除了所有低于某个CLIP分数的图像-文本对。

* 去重。对大规模训练数据集进行去重有助于模型性能，因为它减少了在冗余数据上花费的训练计算（Esser等人，2024；Lee等人，2021；Abbas等人，2023）和记忆（Carlini等人，2023；Somepalli等人，2023）。因此，出于效率和隐私原因，我们对训练数据进行了去重。为此，我们使用最先进的SSCD复制检测模型（Pizzi等人，2022）的内部版本在规模上去除图像重复。对于所有图像，我们首先使用SSCD模型计算512维表示。我们使用这些嵌入在数据集中的所有图像中为每张图像执行最近邻（NN）搜索，使用余弦相似性度量。我们将相似度超过某个阈值的示例定义为重复项。我们使用连接组件算法对这些重复项进行分组，并在每个连接组件中仅保留一个图像-文本对。我们通过以下方式提高去重流程的效率：（1）使用k-means聚类预聚类数据，以及（2）使用FAISS（Johnson等人，2019）进行NN搜索和聚类。

* 重新采样。我们通过类似于Xu等人（2023）；Mahajan等人（2018）；Mikolov等人（2013）的重新采样确保图像-文本对的多样性。首先，我们通过解析高质量文本源构建n-gram词汇表。接下来，我们计算数据集中每个词汇n-gram的频率。然后我们按以下方式重新采样数据：如果标题中的任何n-gram在词汇表中出现次数少于T次，我们保留相应的图像-文本对。否则，我们以概率pT /fi独立地采样标题中的每个n-gram ni，其中fi表示n-gram ni的频率；如果任何n-gram被采样，我们保留图像-文本对。这种重新采样有助于在低频类别和细粒度识别任务上的性能。

* 光学字符识别。我们通过提取图像中书写的文本并将其与字幕连接起来，进一步改善我们的图像-文本数据。使用专有的光学字符识别（OCR）流程提取书面文本。我们观察到，将OCR数据添加到训练数据中大大改善了需要OCR能力的任务，例如文档理解。

**转录文档**。为了提高我们的模型在文档理解任务上的性能，我们将文档页面渲染为图像，并将图像与其各自的文本配对。文档文本直接从源中获取，或通过文档解析流程获取。

**安全**。我们主要关注确保图像识别的预训练数据集不包含不安全内容，例如性虐待材料（CSAM）（Thiel，2023）。我们使用感知散列方法，如PhotoDNA（Farid，2021）以及内部专有分类器扫描所有训练图像中的CSAM。我们还使用专有的媒体风险检索流程来识别和删除我们认为不适合工作场所的图像-文本对，例如，因为它们包含性或暴力内容。我们认为，最小化这类材料在训练数据集中的流行度可以提高最终模型的安全性，而不影响其有用性。最后，我们对训练集中的所有图像进行面部模糊处理。我们使用人类生成的提示测试模型，这些提示引用了附加的图像。

**退火数据**。我们通过使用n-gram重新采样图像-字幕对到较小体积的约3.5亿个示例来创建退火数据集。由于n-gram重新采样偏好更丰富的文本描述，这选择了更高质量的数据子集。我们用来自五个额外来源的约1.5亿个示例增强了生成的数据：

* 视觉定位。我们将文本中的名词短语链接到图像中的边界框或掩码。定位信息（边界框和掩码）以两种方式在图像-文本对中指定。（1）我们在图像上叠加框或掩码，并使用文本中的标记作为参考，类似于标记集（Yang等人，2023a）。（2）我们直接将标准化的（xmin，ymin，xmax，ymax）坐标插入到文本中，用特殊标记分隔。

* 屏幕截图解析。我们从HTML代码渲染屏幕截图，并让模型预测产生屏幕截图中特定元素的代码，类似于Lee等人（2023）。感兴趣的元素通过屏幕截图中的边界框指示。

* 问题-答案对。我们包括问题-答案对，使我们能够使用太大而无法在模型微调中使用的问题-答案数据量。

* 合成字幕。我们包括带有由模型的早期版本生成的合成字幕的图像。与原始字幕相比，我们发现合成字幕比原始字幕提供了更全面的图像描述。

* 合成生成的结构化图像。我们还包括了各种领域（如图表、表格、流程图、数学方程和文本数据）的合成生成图像。这些图像伴随着结构化表示，如相应的markdown或LaTeX符号。

除了提高模型对这些领域的识别能力外，我们发现这些数据对于通过文本模型生成问题-答案对进行微调也很有用。


#### 7.1.2 视频数据

对于视频预训练，我们使用了大量的视频-文本对数据集。我们的数据集是通过多阶段流程精心策划的。我们使用基于规则的启发式方法过滤和清理相关文本，例如确保有最小长度和修正大写。然后，我们运行语言识别模型来过滤掉非英语文本。我们运行OCR检测模型来过滤掉叠加文本过多的视频。为确保视频-文本对之间合理的对齐，我们使用CLIP（Radford等人，2021）风格的图像-文本和视频-文本对比模型。我们首先使用视频中的单一帧计算图像-文本相似性，并过滤掉相似性低的对，然后随后过滤掉视频-文本对齐度低的对。我们的一些数据包含静态或低运动视频；我们使用基于运动得分的过滤（Girdhar等人，2023）过滤掉此类数据。我们没有对视频的视觉质量应用任何过滤器，如审美分数或分辨率过滤。

我们的数据集包含平均时长为21秒的视频，中位数时长为16秒，超过99%的视频时长在一分钟内。空间分辨率在320p和4K视频之间有显著变化，超过70%的视频短边大于720像素。视频具有不同的长宽比，几乎所有视频的长宽比在1:2到2:1之间，中位数为1:1。


### 7.2 模型架构

我们的视觉识别模型由三个主要部分组成：（1）图像编码器，（2）图像适配器，以及（3）视频适配器。

**图像编码器**。我们的图像编码器是一个标准的视觉transformer（ViT; Dosovitskiy等人（2020）），它被训练用于对齐图像和文本（Xu等人，2023）。我们使用的是ViT-H/14变体的图像编码器，它有6.3亿参数，这些参数是在25亿图像-文本对上训练了五个周期。图像编码器是在224×224分辨率的图像上预训练的；图像被分割成16×16个相等大小的块（即，每个块的大小为14x14像素）。正如先前的工作（如ViP-Llava（Cai等人，2024））所展示的，我们观察到通过对比文本对齐目标训练的图像编码器无法保留细粒度的定位信息。为了缓解这个问题，我们采用了多层特征提取，除了最后一层的特征外，还提供了来自第4层、第8层、第16层、第24层和第31层的特征。

此外，我们在交叉注意力层的预训练之前进一步插入了8个门控自注意力层（总共40个transformer块），以学习对齐特定特征。因此，图像编码器最终总共有8500万个参数，加上额外的层。有了多层特征，图像编码器为每个产生的16×16=256个块生成了一个7680维的表示。在后续的训练阶段，我们没有冻结图像编码器的参数，因为我们发现这可以提高性能，特别是在文本识别等领域。

**图像适配器**。我们在图像编码器产生的视觉上的标记表示和语言模型产生的标记表示之间引入了交叉注意力层（Alayrac等人，2022）。交叉注意力层在核心语言模型的每第四个自注意力层之后应用。像语言模型本身一样，交叉注意力层使用广义查询注意力（GQA）以提高效率。交叉注意力层向模型引入了大量的额外可训练参数：对于Llama 3 405B，交叉注意力层有大约1000亿参数。我们分两个阶段预训练我们的图像适配器：（1）初始预训练，然后是（2）退火：

* 初始预训练。我们在上述描述的约60亿图像-文本对数据集上预训练我们的图像适配器。出于计算效率的考虑，我们将所有图像调整大小以适应最多四个336×336像素的瓦片，我们将瓦片排列以支持不同的长宽比，例如672×672、672×336和1344×336。

* 退火。我们继续在上述描述的退火数据集的约5亿图像上训练图像适配器。在退火过程中，我们增加了每个瓦片的图像分辨率，以提高需要更高分辨率图像的任务的性能，例如信息图表的理解。

**视频适配器**。我们的模型接受最多64帧（从完整视频中均匀采样），每帧都由图像编码器处理。我们通过两个组件对视频中的时间结构进行建模：（i）编码后的视频帧通过时间聚合器进行聚合，该聚合器将32连续帧合并为一个，（ii）在每第四个图像交叉注意力层之前添加额外的视频交叉注意力层。时间聚合器实现为感知器重采样器（Jaegle等人，2021；Alayrac等人，2022）。我们使用每视频16帧（聚合为1帧）进行预训练，但在监督微调期间将输入帧数增加到64。对于Llama 3 7B和70B，视频聚合器和交叉注意力层分别有6亿和46亿参数。


### 7.3 模型扩展

在将视觉识别组件添加到Llama 3之后，模型包含了自注意力层、交叉注意力层和ViT图像编码器。为了训练较小的8B和70B参数模型的适配器，我们发现数据和张量并行的组合是最高效的。在这些规模上，模型或流水线并行性不会提高效率，因为模型参数的聚合将主导计算。然而，在训练405B参数模型的适配器时，我们确实使用了流水线并行性（除了数据和张量并行）。在这个规模上的训练引入了除了第3.3节中概述的之外的三个新挑战：模型异构性、数据异构性和数值不稳定性。

**模型异构性**。模型计算是异构的，因为一些token比其他token执行了更多的计算。特别是，图像token由图像编码器和交叉注意力层处理，而文本token仅由语言骨干处理。这种异构性导致了流水线并行性调度中的瓶颈。我们通过确保每个流水线阶段包含五层来解决这个问题：即语言骨干中的四个自注意力层和一个交叉注意力层。（回想一下，我们在每第四个自注意力层之后引入一个交叉注意力层。）此外，我们在所有流水线阶段复制图像编码器。因为我们在成对的图像-文本数据上训练，这使我们能够在计算的图像和文本部分之间进行负载平衡。

**数据异构性**。数据是异构的，因为平均来说，图像比相关文本有更多的token：一张图像有2308个token，而相关文本平均只有192个token。因此，交叉注意力层的计算比自注意力层的计算需要更多的时间和内存。我们通过在图像编码器中引入序列并行性来解决这个问题，以便每个GPU处理大致相同数量的token。由于平均文本大小相对较短，我们还使用了更大的微批量大小（8而不是1）。

**数值不稳定性**。在将图像编码器添加到模型后，我们发现在bf16中执行梯度累积导致了数值不稳定性。这最可能的解释是，图像token通过所有交叉注意力层引入到语言骨干中。这意味着图像token的表示中的数值偏差对整体计算有巨大的影响，因为错误是累积的。我们通过在FP32中执行梯度累积来解决这个问题。

### 7.4 预训练

**图像**。我们从预训练的文本模型和视觉编码器权重开始初始化。视觉编码器是解冻的，而文本模型权重则如上所述保持冻结。首先，我们使用每个图像调整大小以适应四个336×336像素瓦片的60亿图像-文本对来训练模型。我们使用16384的全局批量大小和余弦学习率计划，初始学习率为$10 \times 10^{-4}$，权重衰减为0.01。初始学习率是基于小规模实验确定的。然而，这些发现并没有很好地推广到非常长的训练计划，在训练期间损失值停滞不前时，我们几次降低了学习率。在基础预训练之后，我们进一步提高图像分辨率，并在退火数据集上继续使用相同的权重进行训练。优化器通过预热重新初始化为学习率$2 \times 10^{-5}$，然后再次遵循余弦计划。

**视频**。对于视频预训练，我们从上述描述的图像预训练和退火权重开始。我们添加了视频聚合器和交叉注意力层，如架构中所述，随机初始化。我们冻结了模型中的所有参数，除了视频特定的参数（聚合器和视频交叉注意力），并在视频预训练数据上训练它们。我们使用与图像退火阶段相同的训练超参数，学习率有小的差异。我们从完整视频中均匀采样16帧，并使用每个448×448像素的四个块来表示每一帧。我们在视频聚合器中使用16的聚合因子，因此获得一个有效的帧，文本token交叉关注它。我们使用4096的全局批量大小，190个token的序列长度，在训练期间使用$10^{-4}$的学习率。

### 7.5 后训练

在本节中，我们描述了我们视觉适配器的后训练配方。预训练后，我们在高度策划的多模态对话数据上对模型进行微调，以启用聊天功能。我们进一步实施直接偏好优化（DPO）以提高人类评估性能，并采用拒绝采样以提高多模态推理能力。最后，我们增加了一个质量调整阶段，我们在非常小的一组高质量对话数据上继续微调模型，这在保留基准测试性能的同时进一步提高了人类评估。

#### 7.5.1 监督微调数据

我们分别描述了图像和视频能力的监督微调（SFT）数据。

**图像**。我们利用不同的数据集混合进行监督微调。

* 学术数据集。我们使用模板或通过LLM重写将高度筛选的现有学术数据集转换为问答对。LLM重写的目的是用不同的指令增强数据，并提高答案的语言质量。
* 人类注释。我们通过人类注释者收集多模态对话数据，涵盖广泛的任务（开放式问答、字幕、实际用例等）和领域（例如，自然图像和结构化图像）。注释者被提供图像，并被要求编写对话。为确保多样性，我们在不同集群中均匀地聚类大规模数据集和采样图像。此外，我们通过k最近邻扩展种子来获取一些特定领域的额外图像。注释者还被提供现有模型的中间检查点，以促进模型在循环中的注释风格，使模型生成可以作为注释者提供的额外人类编辑的起点。这是一个迭代过程，其中模型检查点将定期更新为在最新数据上训练的更好执行版本的模型。这增加了人类注释的体积和效率，同时也提高了它们的质量。
* 合成数据。我们探索使用图像的文本表示和文本输入LLM生成合成多模态数据的不同方法。高层思路是利用文本输入LLM的推理能力在文本领域生成问答对，并将文本表示替换为其相应的图像以产生合成多模态数据。示例包括将问答数据集中的文本渲染为图像或将表格数据渲染为表格和图表的合成图像。此外，我们还使用现有图像的字幕和OCR提取来生成与图像相关的额外对话或问答数据。

**视频**。类似于图像适配器，我们使用具有预先存在的注释的学术数据集，并将它们转换为适当的文本指令和目标响应。目标被转换为开放式响应或多项选择选项，视情况而定。我们要求人类用问题和相应的答案注释视频。注释者被要求专注于不能仅基于单个帧回答的问题，以引导注释者提出需要时间理解的问题。

#### 7.5.2 监督微调配方

我们分别描述了图像和视频能力的监督微调（SFT）配方。

**图像**。我们从预训练的图像适配器开始初始化，但将预训练的语言模型权重与指令调整的语言模型权重进行热交换。为了保持仅文本性能，语言模型权重保持冻结，即我们只更新视觉编码器和图像适配器权重。

我们对模型进行微调的方法类似于Wortsman等人（2022）。首先，我们使用多个随机数据子集、学习率和权重衰减值进行超参数扫描。接下来，我们根据它们的表现对模型进行排名。最后，我们平均顶级K模型的权重以获得最终模型。K值是通过评估平均模型并选择最高性能的实例来确定的。我们观察到平均模型始终比通过网格搜索找到的最佳单个模型产生更好的结果。此外，这种策略减少了对超参数的敏感性。

**视频**。对于视频SFT，我们使用预训练权重初始化视频聚合器和交叉注意力层。模型中的其余参数，图像权重和LLM，从相应的模型中初始化，跟随它们的微调阶段。类似于视频预训练，我们然后仅在视频SFT数据上微调视频参数。在这个阶段，我们将视频长度增加到64帧，并使用32的聚合因子获得两个有效帧。块的分辨率也增加，以与相应的图像超参数一致。

#### 7.5.3 偏好数据

我们为奖励建模和直接偏好优化构建了多模态成对偏好数据集。

* 人类注释。人类注释的偏好数据包括两个不同模型输出之间的比较，标记为“选择”和“拒绝”，并带有7级评分。用于生成响应的模型是从最佳近期模型池中即时采样的，每个模型具有不同的特征。我们每周更新模型池。除了偏好标签，我们还要求注释者提供可选的人类编辑，以纠正“选择”响应中的不准确性，因为视觉任务对不准确性的容忍度很低。注意，人类编辑是可选步骤，因为在实践中存在体积和质量之间的权衡。

* 合成数据。也可以通过使用仅文本LLM编辑和故意在监督微调数据集中引入错误来生成合成偏好对。我们将对话数据作为输入，并使用LLM引入微妙但有意义的错误（例如，更改对象、更改属性、添加计算错误等）。这些编辑后的响应用作负面的“拒绝”样本，并与“选择”原始监督微调数据配对。

* 拒绝采样。此外，为了创建更多的策略内负样本，我们利用拒绝采样的迭代过程收集额外的偏好数据。我们在以下部分更详细地讨论我们对拒绝采样的使用。在高层次上，拒绝采样用于迭代地从模型中采样高质量生成。因此，作为副产品，所有未被选择的生成都可以用作负面拒绝样本，并用作额外的偏好数据对。


#### 7.5.4 奖励建模

我们在视觉SFT模型和语言RM的基础上训练一个视觉奖励模型（RM）。视觉编码器和交叉注意力层从视觉SFT模型中初始化并在训练期间解冻，而自注意力层从语言RM中初始化并保持冻结。我们观察到冻结语言RM部分通常可以带来更高的准确性，特别是在需要RM根据其知识或语言质量进行判断的任务上。我们采用与语言RM相同的训练目标，但增加了一个加权正则化项，该项作用于批次平均奖励logits的平方，这防止了奖励分数的漂移。

第7.5.3节中的人类偏好注释用于训练视觉RM。我们按照语言偏好数据（第4.2.1节）的相同做法，创建两到三对具有明确排名的配对（编辑 > 选择 > 拒绝）。此外，我们还通过扰乱与图像中的信息（如数字或视觉文本）相关的单词或短语，来增强负面响应。这鼓励视觉RM根据实际图像内容做出判断。

#### 7.5.5 直接偏好优化

与语言模型（第4.1.4节）类似，我们使用第7.5.3节中描述的偏好数据，通过直接偏好优化（DPO；Rafailov等人（2023））进一步训练视觉适配器。为了对抗后训练轮次中的分布偏移，我们只保留最近的人类偏好注释批次，同时丢弃那些足够偏离策略的批次（例如，如果基础预训练模型发生了变化）。我们发现，不是始终冻结参考模型，而是每k步以指数移动平均（EMA）的方式更新它，有助于模型更多地从数据中学习，从而在人类评估中获得更好的表现。总体而言，我们观察到视觉DPO模型在每次微调迭代的人类评估中的表现始终优于其SFT起点。

#### 7.5.6 拒绝采样

大多数可用的问答对只包含最终答案，缺少训练一个能够很好地泛化推理任务的模型所需的思维链解释。我们使用拒绝采样为这些例子生成缺失的解释，并增强模型的推理能力。

给定一个问题-答案对，我们通过使用不同的系统提示或温度对微调模型进行采样，生成多个答案。接下来，我们通过启发式或LLM裁判将生成的答案与真实答案进行比较。最后，我们通过将正确答案重新添加到微调数据混合中来重新训练模型。我们发现保留每个问题的多个正确答案很有用。

为确保我们只将高质量的示例重新添加到训练中，我们实施了以下两个保护措施。首先，我们发现有些示例尽管最终答案正确，但包含的解释却是错误的。我们观察到这种模式更频繁地出现在只有一小部分生成答案正确的问题上。因此，我们放弃了那些答案正确概率低于某个阈值的问题的答案。其次，评估者由于语言或风格的差异而偏好某些答案。我们使用奖励模型选择最高质量答案的前K名，并将它们重新添加到训练中。

#### 7.5.7 质量调整

我们策划了一个小而高度精选的SFT数据集，所有样本都经过人类或我们最好的模型重写和验证，以满足我们的最高标准。我们使用这些数据训练DPO模型以提高响应质量，将这个过程称为质量调整（QT）。我们发现，当QT数据集涵盖了广泛的任务并且应用了适当的早期停止时，QT显著提高了人类评估的表现，而不影响通过基准测试验证的泛化能力。在这个阶段，我们仅基于基准测试选择检查点，以确保能力得以保留或提高。

### 7.6 图像识别结果
我们在一系列任务上评估了Llama 3图像理解能力的表现，这些任务涵盖了自然图像理解、文本理解、图表理解和多模态推理：

* MMMU (Yue等人，2024a) 是一个具有挑战性的数据集，用于多模态推理，期望模型理解图像并解决涵盖30个不同学科的大学水平问题。这包括多项选择和开放式问题。我们按照其他作品的做法，在包含900张图像的验证集上评估我们的模型。
* VQAv2 (Antol等人，2015) 测试模型结合图像理解、语言理解和常识来回答关于自然图像的通用问题的能力。
* AI2 Diagram (Kembhavi等人，2016) 评估模型解析科学图表并回答相关问题的能力。我们使用与Gemini和x.ai相同的评估协议，并使用透明边框报告分数。
* ChartQA (Masry等人，2022) 是一个具有挑战性的图表理解基准。这要求模型直观地理解不同类型的图表并回答有关图表的逻辑问题。
* TextVQA (Singh等人，2019) 是一个流行的基准数据集，要求模型读取并推理图像中的文本以回答有关它们的问题。这测试了模型在自然图像上的OCR理解能力。
* DocVQA (Mathew等人，2020) 是一个专注于文档分析和识别的基准数据集。它包含各种文档的图像，评估模型执行OCR理解和推理文档内容以回答问题的能力。

表29展示了我们的实验结果。表中的结果表明，附加到Llama 3的视觉模块在不同模型容量的广泛图像识别基准测试中表现出竞争力。使用我们生成的Llama 3-V 405B模型，我们在所有基准测试中都优于GPT-4V，虽然略逊于Gemini 1.5 Pro和Claude 3.5 Sonnet。Llama 3 405B在文档理解任务上特别具有竞争力。

<a>![](/img/llama3/25.png)</a>
**表29 我们附加到Llama 3的视觉模块的图像理解性能。我们将模型性能与GPT-4V、GPT-4o、Gemini 1.5 Pro和Claude 3.5 Sonnet进行比较。使用外部OCR工具获得的结果。**

### 7.7 视频识别结果

我们在三个基准测试上评估了Llama 3的视频适配器：

* PerceptionTest (Pătrăucean等人，2023) 评估模型回答关注技能（记忆、抽象、物理、语义）和不同类型的推理（描述性、解释性、预测性、反事实）的时间推理问题的能力。它包含11.6K个测试QA对，每个视频平均23秒长，由全球100名参与者拍摄，展示感知上有趣的任务。我们专注于多项选择问答任务，每个问题都有三个可能的选项。我们通过将我们的预测提交到在线挑战服务器来报告在保留的测试分割上的表现。
* NExT-QA (Xiao等人，2021) 是另一个时间和因果推理基准，侧重于开放式问答。它包含1K个测试视频，每个平均44秒长，搭配9K个问题。评估是通过将模型的响应与真实答案使用Wu-Palmer相似度（WUPS）(Wu和Palmer，1994)进行比较来执行的。
* TVQA (Lei等人，2018) 评估模型执行组合推理的能力，需要时空定位相关时刻、识别视觉概念和与基于字幕的对话联合推理。这个数据集源自流行的电视节目，此外还测试了模型利用其对这些电视节目的外部知识回答问题的能力。它包含超过15K个验证QA对，每个相应的视频片段平均76秒长。它还遵循多项选择格式，每个问题有五个选项，我们按照先前的工作（OpenAI，2023b）在验证集上报告性能。
* ActivityNet-QA (Yu等人，2019) 评估模型对长视频片段进行推理以理解动作、空间关系、时间关系、计数等的能力。它包含来自800个视频的8K个测试QA对，每个视频平均3分钟长。对于评估，我们遵循先前工作的协议（Google，2023；Lin等人，2023；Maaz等人，2024），其中模型生成短的一词或短语答案，并通过GPT-3.5 API评估输出的正确性，将其与真实答案进行比较。我们报告API评估的平均准确率。

在进行推理时，我们从完整视频片段中均匀采样帧，并将这些帧与简短的文本提示一起输入模型。由于我们的大多数基准测试涉及回答多项选择问题，我们使用以下提示：从以下选项中选择正确答案：{问题}。用正确的选项字母回答，其他什么都不要写。对于那些需要产生简短答案的基准测试（例如，ActivityNet-QA和NExT-QA），我们使用以下提示：用一个词或短语回答问题。{问题}。对于NExT-QA，由于评估指标（WUPS）对长度和使用的具体单词敏感，我们另外提示模型要具体，并以最突出的答案回应，例如，在被问及位置问题时，指定“客厅”而不是简单地回应“房子”。对于那些包含字幕的基准测试（即，TVQA），我们在推理期间在提示中包含片段对应的字幕。

我们在表30中展示了Llama 3 8B和70B的性能。我们将Llama 3的性能与两个Gemini和两个GPT-4模型进行了比较。请注意，由于我们在训练或微调数据中没有包含这些基准测试的任何部分，因此我们所有的结果都是零样本的。我们发现，在后训练期间训练了小型视频适配器的Llama 3模型非常有竞争力，甚至在某些情况下比其他可能从预训练开始就利用原生多模态处理的模型更好。鉴于我们只评估了8B和70B参数模型，Llama 3在视频识别上表现尤为出色。Llama 3在PerceptionTest上表现最佳，表明该模型具有执行复杂时间推理的强能力。在像ActivityNet-QA这样的长篇活动理解任务上，即使模型只处理到64帧，Llama 3也能获得强大的结果，这意味着对于3分钟长的视频，模型每3秒只处理一帧。

<a>![](/img/llama3/26.png)</a>
**表30 我们附加到Llama 3的视觉模块的视频理解性能。我们发现，在涵盖长篇和时间视频理解的任务范围内，我们为Llama 3的8B和70B参数的视觉适配器具有竞争力，有时甚至超越了其他模型。**


## 8 语音实验

我们进行实验，研究将语音能力以组合方式整合到Llama 3中的方法，类似于我们用于视觉识别的方法。在输入端，一个编码器和一个适配器被结合用来处理语音信号。我们利用文本形式的系统提示来启用Llama 3中不同的语音理解模式。如果没有提供系统提示，模型作为一个通用的口语对话模型，能够以与Llama 3文本版本一致的方式有效响应用户的语音。对话历史被引入作为提示前缀，以改善多轮对话体验。我们还尝试使用系统提示，启用Llama 3用于自动语音识别（ASR）和自动语音翻译（AST）。Llama 3的语音接口支持多达34种语言。它还允许文本和语音的交错输入，使模型能够解决高级的音频理解任务。

我们还尝试了一种语音生成方法，我们实现了一个流式文本到语音（TTS）系统，在语言模型解码期间即时生成语音波形。我们为Llama 3设计的语音生成器基于专有的TTS系统，并没有为语音生成微调语言模型。相反，我们专注于通过在推理时利用Llama 3嵌入来提高语音合成的延迟、准确性和自然性。语音界面在图28和29中说明。


<a>![](/img/llama3/27.png)</a>
*图29 Llama 3的语音接口架构。*

### 8.1 数据

#### 8.1.1 语音理解

训练数据可以分为两种类型。预训练数据包括大量未标记的语音，用于以自监督方式初始化语音编码器。监督微调数据包括语音识别、语音翻译和口语对话数据；当与大型语言模型集成时，这些数据用于解锁特定能力。

**预训练数据**。为了预训练语音编码器，我们策划了一个大约1500万小时的语音录音数据集，涵盖了许多语言。我们使用语音活动检测（VAD）模型过滤我们的音频数据，并选择VAD阈值高于0.7的音频样本进行预训练。在语音预训练数据中，我们还专注于确保没有个人身份信息（PII）。我们使用Presidio Analyzer来识别此类PII。

**语音识别和翻译数据**。我们的ASR训练数据包含23万小时的手动转录语音录音，涵盖34种语言。我们的AST训练数据包含9万小时的翻译，两个方向：从33种语言到英语，以及从英语到33种语言。这些数据包含使用NLLB工具包（NLLB团队等人，2022）生成的监督和合成数据。使用合成AST数据使我们能够提高低资源语言的模型质量。我们数据中的语音段的最大长度为60秒。

**口语对话数据**。为了微调口语对话的语音适配器，我们通过要求语言模型响应这些提示的转录，合成地生成语音提示的响应（Fathullah等人，2024）。我们以这种方式使用ASR数据集的子集生成60,000小时的合成数据。此外，我们通过在用于微调Llama 3的数据子集上运行Voicebox TTS系统（Le等人，2024），生成了25,000小时的合成数据。我们使用几种启发式方法选择与语音分布匹配的微调数据子集。这些启发式方法包括专注于相对简短的提示，具有简单结构，且没有非文本符号。

#### 8.1.2 语音生成

语音生成数据集主要包括用于训练文本规范化（TN）模型和韵律模型（PM）的数据。两种训练数据都通过Llama 3嵌入的额外输入特征增强，以提供上下文信息。

**文本规范化数据**。我们的TN训练数据集包括55,000个样本，涵盖了需要非平凡规范化的广泛符号类别（例如，数字、日期、时间）。每个样本是书面形式文本和相应的规范化口语形式文本的配对，以及执行规范化的手工TN规则的推断序列。

**韵律模型数据**。PM训练数据包括从50,000小时TTS数据集中提取的语言学和韵律特征，这些是由专业配音演员在录音室环境中录制的配对文稿和音频。

**Llama 3嵌入**。Llama 3嵌入被取作第16个解码器层的输出。我们专门使用Llama 3 8B模型，并提取给定文本的嵌入（即TN的书面形式输入文本或PM的音频文稿），就好像它们是由带有空用户提示的Llama 3模型生成的。在给定样本中，Llama 3令牌序列中的每个块都与TN或PM的原生输入序列中的相应块明确对齐，即，TN特定的文本令牌（由unicode类别分隔）或电话速率特征。这允许使用Llama 3令牌和嵌入的流输入来训练TN和PM模块。

### 8.2 模型架构

#### 8.2.1 语音理解

在输入端，语音模块由两个连续的模块组成：语音编码器和适配器。语音模块的输出直接输入到语言模型作为标记表示，实现语音和文本标记之间的直接交互。此外，我们引入了两个新的特殊的标记来包围语音表示序列。语音模块与视觉模块（见第7节）有很大的不同，后者通过交叉注意力层将多模态信息输入到语言模型中。相比之下，语音模块生成的嵌入可以无缝地与文本标记集成，使语音接口能够利用Llama 3语言模型的所有能力。

**语音编码器**。我们的语音编码器是一个具有10亿参数的Conformer模型。模型的输入由80维的mel频谱图特征组成，首先由一个步长为4的堆叠层处理，然后通过线性投影将帧长度减少到40毫秒。然后由24层Conformer层处理得到的特征。每个Conformer层具有1536的潜在维度，并包含两个Macron-net风格的前馈网络，其维度为4096，一个卷积模块，核大小为7，以及一个旋转注意力模块（Su等人，2024）和24个注意力头。

**语音适配器**。语音适配器包含大约1亿参数。它由一个卷积层、一个旋转Transformer层和一个线性层组成。卷积层的核大小为3，步长为2，旨在将语音帧长度减少到80毫秒。这允许模型向语言模型提供更粗粒度的特征。Transformer层具有3072的潜在维度和一个4096维度的前馈网络，这在卷积下采样后进一步处理语音信息和上下文。最后，线性层将输出维度映射以匹配语言模型嵌入层。

#### 8.2.2 语音生成

我们在语音生成的两个关键组件中使用Llama 3 8B嵌入：文本规范化和韵律建模。TN模块通过上下文转换书面文本为口语形式，确保生成语音的语义正确性。PM模块通过使用这些嵌入预测韵律特征来增强自然性和表现力。它们共同实现准确和自然的语音生成。

**文本规范化**。作为生成语音语义正确性的决定因素，文本规范化（TN）模块执行从书面形式文本到最终由下游组件口头表达的口语形式的上下文感知转换。例如，书面形式文本123根据语义上下文被读作基数词（一百二十三）或逐位拼写（一二三）。TN系统由一个流式LSTM基础序列标记模型组成，该模型预测用于转换输入文本的一系列手工TN规则（Kang等人，2024）。神经模型还通过交叉注意力接收Llama 3嵌入，利用其中编码的上下文信息，实现最小的文本标记前瞻和流式输入/输出。

**韵律建模**。为了增强合成语音的自然性和表现力，我们集成了一个仅解码器的基于Transformer的韵律模型（PM）（Radford等人，2021），它将Llama 3嵌入作为额外的输入。这种集成利用了Llama 3的语言能力，使用其文本输出和中间嵌入在标记速率（Devlin等人，2018；Dong等人，2019；Raffel等人，2020；Guo等人，2023）来增强韵律特征的预测，从而减少了模型所需的前瞻。

PM集成了几个输入组件以生成全面的韵律预测：从上述文本规范化前端派生的语言学特征、标记和嵌入。PM预测三个关键的韵律特征：每个音素的对数持续时间、对数基频（基频）平均值以及在整个音素持续时间内的对数功率平均值。模型包括一个单向Transformer和六个注意力头。每个块包括交叉注意力层和两个具有864隐藏维度的全连接层。PM的一个显著特点是其双重交叉注意力机制，一层专门用于语言输入，另一层专门用于Llama嵌入。这种设置有效地管理了不同的输入速率，而无需显式对齐。

### 8.3 训练方法

#### 8.3.1 语音理解

语音模块的训练分为两个阶段。第一阶段是语音预训练，利用未标记的数据训练一个在不同语言和声学条件下具有强大泛化能力的语音编码器。第二阶段是监督微调，适配器和预训练编码器与语言模型集成在一起，在LLM保持冻结的状态下与它一起训练。这使模型能够响应语音输入。这个阶段使用的是有标记的数据，对应于语音理解能力。

多语种ASR和AST建模通常会导致语言混淆/干扰，从而导致性能下降。缓解这个问题的一种流行方法是在源语言和目标语言两侧都加入语言识别（LID）信息。这可以在预定的方向上提高性能，但确实会带来潜在的泛化能力损失。例如，如果翻译系统期望在源语言和目标语言两侧都有LID，那么模型在训练中未见的方向上可能不会表现出良好的零样本性能。因此，我们的挑战是设计一个系统，它在一定程度上允许LID信息，但保持模型的通用性，以便我们可以在未见的方向上进行语音翻译。为了解决这个问题，我们设计了系统提示，其中只包含要发出的文本（目标侧）的LID。这些提示中没有语音输入（源侧）的LID信息，这也可能允许它与代码切换的语音一起工作。对于ASR，我们使用以下系统提示：请用{language}语重复我的话：，其中{language}来自34种语言中的一种（英语、法语等）。对于语音翻译，系统提示是：将以下句子翻译成{language}。这种设计已被证明在促使语言模型以期望的语言响应方面是有效的。我们在训练和推理中使用了相同的系统提示。

**语音预训练**。我们使用自监督BEST-RQ算法（Chiu等人，2022）预训练语音编码器。我们对输入的mel频谱图应用了32帧长度的掩码，掩码概率为2.5%。如果语音话语超过60秒，我们执行6K帧的随机裁剪，相当于60秒的语音。我们通过将4个连续帧堆叠起来，将320维向量投影到16维空间，并在8192个向量的码本内进行余弦相似性度量的最近邻搜索，来量化mel频谱图特征。为了稳定预训练，我们采用16个不同的码本。投影矩阵和码本是随机初始化的，在模型训练期间不更新。为了效率，仅在掩蔽帧上使用multi-softmax损失。编码器用2,048个话语的全局批量大小训练了50万步。

**监督微调**。预训练的语音编码器和随机初始化的适配器在监督微调阶段进一步与Llama 3一起优化。在这个过程中，语言模型保持不变。训练数据是ASR、AST和口语对话数据的混合。Llama 3 8B的语音模型用512个话语的全局批量大小训练了65万次更新，初始学习率为$10^{-4}$。Llama 3 70B的语音模型用768个话语的全局批量大小训练了60万次更新，初始学习率为$4 \times 10^{-5}$。

#### 8.3.2 语音生成

为了支持实时处理，韵律模型采用前瞻机制，考虑固定数量的未来音素和变化数量的未来标记。这确保了在处理传入文本时具有一致的前瞻，这对于低延迟语音合成应用至关重要。

**训练**。我们开发了一种利用因果掩蔽的动态对齐策略，以促进语音合成中的流式处理。这种策略结合了固定数量未来音素的前瞻机制和变化数量未来标记的前瞻机制，与文本规范化期间的分块过程（第8.1.2节）相一致。对于每个音素，标记前瞻包括由块大小定义的最大标记数量，从而实现Llama嵌入的变化前瞻，但对音素的前瞻是固定的。

Llama 3嵌入来自Llama 3 8B模型，在韵律模型训练期间保持冻结。输入的音素速率特征包括语言学和说话者/风格可控性元素。模型训练采用每批1,024个话语，每个话语的最大长度为500个音素。我们使用9 × 10^-4的学习率，使用AdamW优化器，在前3,000次更新进行学习率预热后，按照余弦时间表训练100万次更新。

**推理**。在推理过程中，采用相同的前瞻机制和因果掩蔽策略，以确保训练和实时处理之间的一致性。PM以流式方式处理传入的文本，逐个音素更新音素速率特征，逐块更新标记速率特征。只有当该块的第一个音素当前时，才更新新的块输入，保持与训练期间的对齐和前瞻。

对于韵律目标预测，我们采用延迟模式方法（Kharitonov等人，2021），这增强了模型捕获和再现长期韵律依赖性的能力。这种方法有助于合成语音的自然性和表现力，确保了低延迟和高质量的输出。


### 8.4 语音理解结果

我们在三项任务上评估了Llama 3的语音接口的语音理解能力：（1）自动语音识别，（2）语音翻译，以及（3）口语问题回答。我们将Llama 3的语音接口的性能与三种语音理解的最先进模型进行比较：Whisper（Radford等人，2023年）、SeamlessM4T（Barrault等人，2023年）和Gemini。在所有评估中，我们对Llama 3的标记预测使用了贪婪搜索。

**语音识别**。我们在多语种LibriSpeech（MLS；Pratap等人（2020年））、LibriSpeech（Panayotov等人，2015年）、VoxPopuli（Wang等人，2021a）以及多语种FLEURS数据集的一个子集（Conneau等人，2023年）的英语数据集上评估了ASR性能。在评估中，解码结果使用Whisper文本规范化工具进行后处理，以确保与其它模型报告的结果进行一致性比较。在所有基准测试中，我们测量了Llama 3的语音接口在这些基准的标准测试集上的词错误率，除了中文、日文、韩文和泰语，这些语言报告的是字符错误率。

表31显示了ASR评估的结果。它展示了Llama 3（以及更普遍的多模态基础模型）在语音识别任务上的强性能：我们的模型在所有基准测试中都优于像Whisper和SeamlessM4T这样专为语音定制的模型。在MLS英语上，Llama 3的表现与Gemini相似。

<a>![](/img/llama3/28.png)</a>
*表31 Llama 3的语音接口在语音识别任务上的词错误率。我们报告了Whisper、SeamlessM4T和Gemini的性能以供参考。*

**语音翻译**。我们还评估了模型在语音翻译任务上的性能，其中模型被要求将非英语语音翻译成英文文本。我们使用FLEURS和Covost 2（Wang等人，2021b）数据集进行这些评估，测量翻译成英语的BLEU分数。表32展示了这些实验的结果。我们模型在语音翻译方面的性能突显了多模态基础模型对于像语音翻译这样的任务的优势。

<a>![](/img/llama3/29.png)</a>
*表32 Llama 3的语音接口在语音翻译任务上的BLEU分数。我们报告了Whisper和SeamlessM4T的性能以供参考。*

**口语问题回答**。Llama 3的语音接口展示了卓越的问题回答能力。模型能够轻松理解代码切换的语音，而无需事先接触此类数据。值得注意的是，尽管模型仅在单轮对话上进行训练，但它能够参与扩展的、连贯的多轮对话会话。图30展示了一些突出这些多语言和多轮对话能力的例子。

<a>![](/img/llama3/30.png)</a>
**图30 使用Llama 3的语音接口转录的对话示例。这些示例展示了零样本多轮对话和代码切换能力。**

**安全性**。我们在MuTox（Costa-jussà等人，2023年）上评估了我们语音模型的安全性，这是一个包含20,000条英语和西班牙语发音的多语种音频数据集，另外还有19种其他语言的4,000条发音，每条都附有毒性标签。音频作为输入传递给模型，输出在清理一些特殊字符后评估其毒性。我们应用了MuTox分类器（Costa-jussà等人，2023年），并将结果与Gemini 1.5 Pro进行了比较。我们评估了添加毒性（AT）的百分比，即输入提示安全而输出有毒时，以及丢失毒性（LT）的百分比，即输入提示有毒而答案安全时。表33显示了英语的结果以及我们评估的所有21种语言的平均值。添加的毒性百分比非常低：我们的语音模型在英语上添加的毒性百分比最低，不到1%。它去除的毒性明显多于它增加的毒性。

<a>![](/img/llama3/33.png)</a>
**表33 Llama 3的语音接口在MuTox数据集上的语音毒性。AT指的是添加的毒性百分比，LT指的是丢失的毒性百分比。**

### 8.5 语音生成结果

对于语音生成，我们专注于评估使用Llama 3嵌入进行文本规范化和韵律建模任务的逐令牌输入流式模型的质量。评估的重点是与不将Llama 3嵌入作为额外输入的模型进行比较。

**文本规范化**。为了衡量Llama 3嵌入的效果，我们尝试改变模型使用的右侧上下文量。我们训练模型时使用了3个TN令牌（由unicode类别分隔）的右侧上下文。这个模型与不使用Llama 3嵌入，使用3个令牌的右侧上下文或完整双向上下文的模型进行了比较。正如预期，表34显示，对于不使用Llama 3嵌入的模型，使用完整右侧上下文可以提高性能。然而，结合了Llama 3嵌入的模型超越了所有其他模型，因此能够在不依赖输入中的长上下文的情况下，实现令牌速率的输入/输出流式处理。

<a>![](/img/llama3/31.png)</a>
**表34 逐样本的文本规范化（TN）准确率。我们比较有无Llama 3 8B嵌入的模型，并使用不同的右侧上下文值。**

**韵律建模**。为了评估我们的韵律模型（PM）与Llama 3 8B的性能，我们进行了两组人类评估，比较有无Llama 3嵌入的模型。评估者听取不同模型的样本并表明他们的偏好。为了生成最终的语音波形，我们使用了一个内部的基于transformer的声学模型（Wu等人，2021年），它预测频谱特征，并使用WaveRNN神经声码器（Kalchbrenner等人，2018年）来生成最终的语音波形。

首先，我们直接与没有Llama 3嵌入的流式基线模型进行了比较。在第二项测试中，Llama 3 8B PM与没有Llama 3嵌入的非流式基线模型进行了比较。正如表35所示，与流式基线相比，Llama 3 8B PM有60%的时间被偏好，与非流式基线相比，有63.6%的时间被偏好，表明在感知质量上有显著改进。Llama 3 8B PM的关键优势是其逐令牌流式能力（第8.2.2节），这在推理期间保持了低延迟。这减少了模型的前瞻要求，与非流式基线相比，实现了更具响应性和实时性的语音合成。总体而言，Llama 3 8B韵律模型一贯优于基线模型，证明了其在增强合成语音的自然性和表现力方面的有效性。


<a>![](/img/llama3/32.png)</a>
**表35 韵律建模（PM）评估。左侧：评估者对Llama 3 8B PM与仅音素流式基线模型的偏好。右侧：评估者对Llama 3 8B PM与非流式仅音素基线模型的偏好。**
