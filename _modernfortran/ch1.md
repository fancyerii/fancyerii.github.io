---
layout:     post
title:      "第一章：Fortran简介"
author:     "lili"
mathjax: true
sticky: true
excerpt_separator: <!--more-->
tags:
    - fortran
---

<!--more-->

**目录**
* TOC
{:toc}

本章内容包括

* 什么是Fortran，为什么要学习它？
* Fortran的优势与劣势
* 并行思维
* 从零开始构建并行模拟应用

这是一本关于Fortran的书，Fortran是历史上最早的高级编程语言之一。本书将通过一步一步地引导你开发一个功能齐全的并行物理模拟应用来教你这门语言。请注意并行编程的强调。并行编程允许你将问题分解成多个部分，并让多个处理器各自处理部分问题，从而更快地找到解决方案。到最后，你将能够识别可以并行化的问题，并使用现代Fortran技术来解决这些问题。

这本书并不是每一个Fortran特性都涵盖的全面参考手册——我有意省略了一些语言的重要部分。相反，我专注于你在构建实际Fortran应用程序时会使用的最实用的特性。在每一章中，我们将应用现代Fortran特性和软件设计技术，使我们的应用程序变得稳健、可移植、易于使用和扩展。这不仅是一本关于Fortran的书，也是一本关于使用现代Fortran构建稳健的并行软件的书。



 


## 1.1 什么是Fortran？

>我不知道2000年的编程语言会是什么样子，但我知道它会被称为Fortran。
>——1980年图灵奖得主托尼·霍尔

Fortran是一种通用的并行编程语言，擅长科学和工程应用。最初在1957年被称为FORTRAN（FORmula TRANslation），经过几十年的发展，它已成为一种稳健、成熟且高性能导向的编程语言。今天，Fortran在许多我们认为理所当然的系统的背后默默运行：

* 数值天气、海洋和海浪预报
* 气候科学与预测
* 用于机械和土木工程的计算流体动力学软件
* 用于设计汽车、飞机和航天器的空气动力学(Aerodynamics)求解器
* 机器学习框架中使用的快速线性代数库
* 世界上最快的超级计算机的基准测试（https://top500.org）

以下是一个具体的例子。在我的工作中，我开发天气、海洋表面波和深海环流的数值模型。多年谈论这个话题时，我发现大多数人不知道天气预报是从哪里来的。他们认为气象学家会聚在一起绘制一张未来一天、一周或一个月的天气图。这只是部分正确。实际上，我们使用复杂的数值模型，在像仓库那么大的计算机上处理大量数据。这些模型模拟大气，以提供对未来天气的有根据的猜测。气象学家使用这些模型的输出创建有意义的天气图，如图1.1所示。该图只是模型生成的所有数据的一小部分。像这样的天气预报输出量以数百GB计算。

<a>![](/img/modernfortran/ch1/1.png)</a>
**图1.1 2017年9月10日由一个用Fortran编写的操作性天气预报模型计算的飓风厄玛预测。阴影和风羽显示地表风速（单位：米/秒），等高线表示海平面气压等值线。典型的天气预报是使用数百或数千个CPU并行计算的。（数据由美国国家海洋和大气管理局（NOAA）国家环境预报中心（NCEP）提供）**

最强大的Fortran应用程序在数百或数千个CPU上并行运行。Fortran语言及其库的发展主要由解决物理学、工程学和生物医学中极其庞大的计算问题的需求驱动。为了获取比当时最强大的单台计算机更大的计算能力，在20世纪末期，我们开始将许多计算机通过高速网络连接起来，让它们各自处理问题的一部分。结果是超级计算机，它由成千上万的普通CPU组成的庞大计算机（如图1.2所示）。超级计算机类似于由谷歌或亚马逊托管的现代服务器农场，只是超级计算机的网络基础设施旨在最大化带宽并最小化服务器之间的延迟，而不是它们与外部世界之间的延迟。因此，超级计算机中的CPU像一个具有分布式内存访问的大型处理器，其访问速度几乎与本地内存访问一样快。直到今天，Fortran仍然是这种大规模并行计算的主导语言。

<a>![](/img/modernfortran/ch1/2.png)</a>
**图1.2 巴塞罗那超级计算中心的MareNostrum 4超级计算机。这台计算机位于西班牙加泰罗尼亚巴塞罗那的Torre Girona教堂内。高速网络将所有机柜连接在一起。MareNostrum 4拥有153,216个英特尔至强核心，是西班牙最快的超级计算机，截至2020年6月，它是世界上第37快的超级计算机（https://www.top500.org/lists/2020/06）。它用于许多科学应用，从天体物理学和材料物理学，到气候和大气尘埃传输预测，再到生物医学。（图片来源：https://www.bsc.es/marenostrum/marenostrum）**



## 1.2 Fortran特性

>这不是你父母用的Fortran。
>——达米安·鲁森

在编程语言的背景下，Fortran具有以下特性：

* 编译型——你将编写完整的程序，并在执行前将它们传递给编译器。这与Python或JavaScript等解释型编程语言不同，后者逐行解析和执行。虽然这使编写程序有点繁琐，但它允许编译器生成高效的可执行代码。在典型的使用情况下，Fortran程序的速度通常比等效的Python程序快一个或两个数量级。

**什么是编译器？**
编译器是一种计算机程序，它读取用一种编程语言编写的源代码，并将其翻译成另一种编程语言的等效代码。在我们的例子中，Fortran编译器将读取Fortran源代码，并生成适当的汇编代码和机器（二进制）指令。


* 静态类型——在Fortran中，你需要声明所有变量的类型，并且它们的类型将在程序结束前保持不变。

```
! 使用之前需要声明
real :: pi
! 直到程序结束pi的类型都是real
pi = 3.141592
```

你还需要在使用变量之前显式声明它们，这称为显式类型声明。最后，Fortran采用所谓的强类型，这意味着如果一个过程使用了错误类型的参数，编译器将会报错。静态类型有助于编译器生成高效的程序，而显式和强类型则强制实施良好的编程习惯，使Fortran成为一种安全的语言。我发现编写正确的Fortran程序比Python或JavaScript更容易，后者有许多隐藏的陷阱和“陷阱”。

* 多范式——你可以用多种不同的范式或风格编写Fortran程序：命令式、过程式、面向对象，甚至函数式。根据你要解决的问题，有些范式比其他范式更合适。我们将在整本书中开发代码时探索不同的范式。

* 并行——Fortran也是一种并行语言。并行性是将计算问题分解为通过网络通信的进程的能力。并行进程可以在同一个处理核心上运行（基于线程的并行性）、在共享RAM的不同核心上运行（共享内存并行性），或分布在网络上（分布式内存并行性）。在同一个并行程序上协作的计算机可以物理上位于同一个机柜内、同一房间内，甚至世界各地。Fortran的主要并行结构是协程数组(coarray)，它允许你在不使用任何外部库的情况下表达并行算法和远程数据交换。协程数组允许你像访问数组元素一样访问远程内存，如下面的示例所示。


```
program hello_coarrays
  ! A coarray variant of a hello world program.
  ! Listing 1.1 in the book.
  implicit none

  integer :: a[*]
  integer :: i

  a = this_image()

  if (this_image() == 1) then
    do i = 1, num_images()
      print *, 'Value on image', i, 'is', a[i]
    end do
  end if

end program hello_coarrays
```

Fortran标准并不规定数据交换在底层如何实现；它仅仅指定了语法和预期行为。这使得编译器开发者能够在任何特定硬件上使用最优的方法。给定一个有能力的编译器和库，Fortran程序员可以编写代码，使其在传统CPU或通用GPU上运行。示例1.1旨在用于说明；然而，如果你希望编译并运行它，请按照附录A中的说明设置你的Fortran开发环境后再进行。

* Fortran的成熟性—2016年，我们庆祝了Fortran诞生60周年。这种语言已经通过几次标准的修订而发展壮大：

    * FORTRAN 66，也被称为FORTRAN IV（ANSI，1966年）
    * FORTRAN 77（ANSI，1978年）
    * Fortran 90（ISO/IEC，1991年；ANSI，1992年）
    * Fortran 95（ISO/IEC，1997年）
    * Fortran 2003（ISO/IEC，2004年）
    * Fortran 2008（ISO/IEC，2010年）
    * Fortran 2018（ISO/IEC，2018年）

Fortran在编译器中的开发和实现得到了行业的大力支持：IBM、Cray、Intel、NAG、NVIDIA等。还有显著的开源发展，其中最值得注意的是免费编译器—gfortran（https://gcc.gnu.org/wiki/GFortran）、Flang（https://github.com/flang-compiler/flang）、LFortran（https://lfortran.org）—以及其他社区项目（https://fortran-lang.org/community）。由于Fortran在计算机科学的早期占主导地位，今天我们拥有了庞大而成熟的库集，这些库是许多应用程序的计算基础。借助成熟的编译器和大量的遗留代码库，Fortran仍然是许多新软件项目的首选语言，尤其是对于那些计算效率和并行执行至关重要的项目。

* 易学—信不信由你，Fortran相当容易学习。这是我的经验，也是许多同事的经验。它容易学习部分是因为它严格的类型系统，这使得编译器能够在编译时保持程序员的检查，并在他们犯错误时发出警告。虽然冗长，语法却清晰易读。然而，和其他编程语言或一般技能一样，Fortran难以精通。这也是我选择写这本书的原因之一。

## 1.3 为什么要学习Fortran？

>这里有一些程序是在五千年前，人类还没有离开地球时编写的。Sura说，令人惊奇——也是令人恐惧——的是，与堪培拉过去那些无用的残骸不同，这些程序仍然可以运行！通过无数曲折的继承链条，许多最古老的程序仍然在Qeng Ho系统的深处运行。
>——Vernor Vinge，《天空的深处》

自1990年代初以来，我们见证了新编程语言和框架的爆炸式增长，主要是由于互联网的广泛使用和后来移动设备的普及。C++占据了计算机科学系，Java在企业界备受推崇，JavaScript重新定义了现代网络，R成为统计学家的母语，Python在机器学习领域掀起了风暴。那么Fortran在其中的地位如何呢？通过语言的不断修订，Fortran在其利基领域——高性能计算（HPC）中保持了稳固的地位。其计算效率仍然无与伦比，只有C和C++能接近它。与C和C++不同，Fortran专为面向数组的计算而设计，在我看来，它更容易学习和编程。最近，Fortran本身对并行编程的原生支持也成为一个强有力的论据。

**什么是高性能计算？**

高性能计算（HPC）是将计算机资源组合在一起，以解决单台桌面计算机无法解决的计算问题的实践。HPC系统通常聚合数百或数千台服务器，并通过高速网络连接它们。今天大多数HPC系统运行某种Linux操作系统。

尽管是一项已有数十年历史的技术，Fortran仍有几个吸引人的特点，使其在与更新语言的比较中不可或缺：

* 面向数组—Fortran提供整体数组运算和操作，这极大地简化了逐元素操作。考虑将两个二维数组相乘的任务：

```
do j = 1, jm
    do i = 1, im
        c(i,j) = a(i,j) * b(i,j)
    end do
end do
```

使用Fortran的整体数组运算，你可以这样写：

```fortran
C = A * B
```

这不仅是更具表现力和可读性的代码，它还向编译器暗示可以选择执行该操作的最佳方式。数组非常适合CPU架构和计算机内存，因为它们是连续的数字序列，因此与内存的物理布局相匹配。Fortran编译器能够生成极其高效的机器代码，这要归功于它们能够安全地做出的假设。

* 唯一由标准委员会（ISO）开发的并行语言—Fortran标准委员会确保Fortran的发展方向支持其目标受众：计算科学家和工程师。

* 成熟的科学、工程和数学库—Fortran始于20世纪50年代，作为科学、工程和数学的编程语言。几十年后，我们拥有丰富的、经过验证的库，用于线性代数、数值微分和积分以及其他数学问题。这些库已经被几代程序员使用和测试，以至于它们几乎可以保证没有错误。

* 日益增长的通用库生态系统—在过去的十年里，Fortran还见证了通用库生态系统的增长：文本解析和操作、支持多种数据格式的I/O库、处理日期和时间、集合和数据结构等等。任何编程语言的强大程度都取决于其库的数量，越来越多的Fortran库使其比以往任何时候都更有用。

* 无与伦比的性能—编译后的Fortran程序在高级编程语言中几乎能达到最接近硬件的程度。这得益于其面向数组的设计和不断优化代码的成熟编译器。如果你在处理对大型数组进行数学运算的问题，几乎没有其他语言能接近Fortran的性能。

总之，如果你需要在大规模多维数组上实现高效和并行的数值运算，那么学习Fortran。


## 1.4 优缺点

许多Fortran的特性既是优点也是缺点。例如，它具备以下特点：

* 领域特定语言—尽管在技术上是一种通用语言，但Fortran在很大程度上是一种领域特定语言，因为它是为科学、工程和数学应用设计的。如果你的问题涉及对大型和结构化数组进行一些算术运算，Fortran将表现得非常出色。如果你想编写一个网络浏览器或底层设备驱动程序，Fortran就不是合适的工具。

* 小众语言—Fortran对相对少量的人非常重要：特定学科的科学家和工程师。因此，可能很难找到像主流语言那么多的关于Fortran的教程或博客。

* 静态和强类型语言—如前所述，这使得Fortran成为一种非常安全的编程语言，并帮助编译器生成高效的可执行文件。但另一方面，这使得它不够灵活，代码也更加冗长，因此不太适合快速原型开发。

接下来的Fortran与Python的对比将帮助你更好地理解其在通用编程环境中的优缺点。

### 1.4.1 与Python的并排比较

现代Fortran与一种更新的通用编程语言相比如何？Python在过去几年中在数据分析和轻量级数值计算方面的生态系统发展最快（http://mng.bz/XP71）。许多Fortran程序员使用Python进行模型输出的后处理和数据分析。实际上，Python是我第二喜欢的编程语言。由于Fortran和Python的应用领域重叠，总结两者之间的关键差异是有用的，如表1.1所示。如果你是Python程序员，这个总结将为你提供关于Fortran可以做什么和不可以做什么的概念。

<a>![](/img/modernfortran/ch1/3.png)</a>
*表1.1 Fortran与Python（特别是CPython）的比较*

从表1.1中，可以看到Fortran和Python之间的一些关键差异。首先，Fortran是编译型和静态类型的，而Python是解释型和动态类型的。这使得Fortran编程更为冗长且编程速度较慢，但允许编译器生成快速的二进制代码。这既是福也是祸：Fortran不适合快速原型开发，但可以生成健壮且高效的程序。其次，Fortran是一种原生并行编程语言，其语法允许你编写独立于是否在共享或分布式内存计算机上运行的并行代码。相比之下，Python中的分布式并行编程只能通过外部库实现，总体上更难实现。最后，Fortran是一种更小的语言，专注于对少数几种不同数值数据类型的大型多维数组进行高效计算。而Python则内置了更多样的数据结构、算法和通用实用程序。

总之，Python类似于一个全面且灵活的工具箱，而Fortran更像是一个高度专业化的电动工具。因此，Fortran不太适合编写设备驱动程序、视频游戏或网络浏览器。但是，如果你需要解决一个可以分布在多台计算机上的大型数值问题，Fortran是你的理想语言。

## 1.5 并行 Fortran，示例说明

我要通过一个示例说明 Fortran 真正擅长解决的问题。我们将这个示例称为“老拉尔夫农场的夏末”。

农夫拉尔夫有两个儿子和两个女儿，还有一个大农场。夏天即将结束，是时候割草并制作干草给牛吃了。但是牧场很大，年老的拉尔夫身体虚弱。然而，他的孩子们年轻且力气大。如果他们齐心协力，共同努力，一天之内就能完成工作。他们同意将工作分成四等份。拉尔夫的每个孩子都拿起镰刀和叉子，前往自己负责的牧场部分。他们努力工作，一排一排地割草。每隔一个小时左右，他们会在边缘集合，磨磨工具，聊聊工作的进展。工作进展顺利，到下午中旬几乎所有的草都割完了。快到一天结束时，他们把干草收集成捆并运到谷仓。老拉尔夫很高兴他有这么强壮勤劳的孩子，但更高兴的是他们是如此出色的团队！共同努力，他们完成了一个人干四倍时间才能完成的工作。

你可能在想，老拉尔夫的农场与并行 Fortran 编程有什么关系？这其中的关联比你想象的更多！老拉尔夫和他的大牧场是慢速计算机和大型计算问题的比喻。就像拉尔夫请求他的孩子们帮忙做农活一样，在典型的并行问题中，我们将计算域或输入数据分成相等的部分，并分配给不同的 CPU。回想一下他的孩子们一排一排地割草——Fortran 代码中最有效和最具表达力的部分之一是整体数组操作和算术运算。定期地，他们在边缘集合磨磨工具，聊聊天。在许多实际应用中，你会指示并行进程交换数据，这适用于本书中我要讲解的大多数并行示例。最后，每个并行进程异步地将数据写入磁盘，就像将干草捆运到谷仓。我在图 1.3 中说明了这一模式。

<a>![](/img/modernfortran/ch1/4.png)</a>
*图 1.3 并行编程模式：分解问题、交换数据、计算并将结果存储到磁盘*

就像农夫拉尔夫一样，Fortran 也是老的编程语言。这绝不是坏事！它是一种成熟、可靠、且值得信赖的语言，并不会消失。尽管它有一些老编程语言的怪癖，但它经过了几代计算机科学家和程序员的改进，并在无数关注性能的应用中得到了实战检验。Fortran 并行编程的简便性是高性能应用的关键，这也是我将其作为本书核心主题的原因。

## 1.6 你将在本书中学到什么？

本书将教你如何编写现代、高效且并行的 Fortran 程序。通过每一章的学习，我们将从零开始构建一个功能齐全的并行流体动力学求解器，专门应用于海啸预测。如果你完成本书的学习，你将获得以下三种独特的技能：

* 你将熟练掌握大多数现代 Fortran 特性。这是一项独特且备受需求的技能，在一个价值数十亿美元的高性能计算（HPC）市场中尤为重要。
* 你将能够识别具有并行特性的问题。你会首先想到并行，并且并行解决方案对你来说将显得直观。相反，对于并行问题的串行解决方案将成为一种边缘案例。
* 你将掌握良好的软件设计、编写可重用代码以及与在线社区分享你的项目的技能。你还能够在项目中适应现有的 Fortran 库并回馈社区。这不仅会使你的项目对他人有用，还能在职业和学习机会方面为你打开大门。这对我而言确实如此！

虽然我不期望你有之前的 Fortran 经验，但我假设你至少有一些编程经验，如 Python、R、MATLAB 或 C。我们不会详细讨论什么是程序、变量、数据类型、源代码或计算机内存，我假设你对这些概念有一定了解。偶尔我们会涉及一些微积分的内容，虽然熟悉它并不是必需的。我们还会在终端中进行大量操作（编译和运行程序），所以我假设你至少对使用命令行感到舒适。不管怎样，为了确保清晰，本书中的任何 Fortran 概念都将从零开始讲解。

鉴于本书的主题，我认为它对以下几类读者非常理想：

* 物理科学、工程或应用数学专业的本科生和研究生，尤其是专注于流体动力学的学生
* 以上领域的教师和研究人员
* 在工业界工作的气象学家、海洋学家及其他流体动力学家
* 想提升并行编程技能的串行 Fortran 程序员
* 高性能计算系统管理员

如果你属于上述类别之一，你可能已经知道 Fortran 的主要卖点是其编写高效并行程序的简便性，适用于大型超级计算机。这使得它在物理科学和工程的高性能计算领域保持主导地位。尽管本书将从基础讲解 Fortran，我还将采用一种不同寻常的方法，从一开始就结合并行编程来教学。你不会只是将另一个技术技能作为事后想法来获得，而是将学习如何以并行思维方式来思考。你会识别出如何分配工作负载和内存，以更高效地得出解决方案。通过并行思维，你将获得两个关键优势：

* 你将能够在更短的时间内解决问题。
* 你将能够解决无法在单台计算机上解决的问题。

虽然第一个优势至少是一个不错的选择，但第二个则是必不可少的。有些问题根本无法在没有并行编程的情况下解决。下一节将为你提供一个温和的引导，并举例说明并行编程。




## 1.7 并行思维！

>十多年来，先驱们一直声称单台计算机的组织结构已达到极限，只有通过连接多台计算机以实现协作解决问题，才能取得真正显著的进步。
>——计算机架构师 Gene Amdahl，1967 年

随着时间的推移，并行编程变得越来越重要。尽管半导体密度增加的速度仍然是正向的，但如摩尔定律所描述，这种速度是有限的。传统上，我们通过在单个芯片上增加更多处理核心来超越这一限制。即使是大多数智能手机中的处理器也是多核的。超越共享内存计算机，我们将许多机器连接成网络，使它们相互通信以解决巨大的计算问题。今天早上的天气预报就是在数百或数千个并行处理器上计算出来的。由于摩尔定律的实际限制和当前对多核架构的趋势，有必要优先教授并行编程。

**什么是摩尔定律？**
英特尔联合创始人戈登·摩尔在 1965 年注意到，CPU 中的晶体管(transistors)数量每年翻一番。他后来将这一趋势修订为每两年翻一番。然而，增加的速度是指数级的，并且与计算机成本的持续下降密切相关。你今天花 1000 美元购买的电脑，其性能约是两年前同样价格的电脑的两倍。

同样，当你购买新智能手机时，操作系统和应用程序运行顺畅而快速。两年后会发生什么？随着应用程序更新并膨胀新功能，它们需要越来越多的 CPU 功率和内存。由于手机的硬件保持不变，最终应用程序运行速度会变得非常慢。

所有并行问题分为两类：

<a>![](/img/modernfortran/ch1/5.png)</a>
**图 1.4 一个显而易见的并行问题（左）与一个非显而易见的并行问题（右）。在这两种情况下，CPU 都接收输入（x1, x2）并进行处理以产生输出（y1, y2）。在显而易见的并行问题中，x1 和 x2 可以相互独立地处理。此外，输入和输出数据在每个 CPU 的内存中都是局部的，用实线箭头表示。在非显而易见的并行问题中，输入数据并不总是位于每个 CPU 的局部内存中，需要通过网络分配，用虚线箭头表示。此外，在计算步骤中，CPU 之间可能存在数据依赖性，这需要同步（水平虚线箭头）。**

* 显而易见的并行(Embarrassingly parallel)问题——这里的“显而易见”是指“非常简单”——这是件好事！这些问题可以轻松地分配到处理器上处理（图 1.4，左）。任何作用于数组 x 上且不需要元素之间通信的函数 f(x) 都是显而易见的并行问题。由于显而易见的并行问题的领域分解很简单，现代编译器通常可以自动并行化这类代码。例如，渲染图形、提供静态网站或处理大量独立数据记录。

* 非显而易见的并行(Nonembarrassingly parallel)问题——任何存在进程间依赖性的并行问题都需要通信和同步（图 1.4，右）。大多数偏微分方程求解器都是非显而易见的并行问题。通信与计算的相对量决定了并行问题的可扩展性。因此，大多数物理求解器的目标是最大限度地减少通信并最大化计算。示例包括天气预报、分子动力学以及任何由偏微分方程描述的物理过程。这类并行问题更为复杂，在我看来也更有趣！

**为什么称之为显而易见的并行问题？**

这指的是过多，就像丰富的财富。这是你希望遇到的问题。该术语归因于 MATLAB 的发明者和 EISPACK 及 LINPACK（用于数值计算的 Fortran 库）作者之一 Cleve Moler。LINPACK 仍然用于评估世界上最快的超级计算机。

由于我们的应用领域主要涉及非显而易见的并行问题，我们将重点关注以简洁、富有表现力和最小化的方式实现并行数据通信。这将涉及在处理器之间分配输入数据（图 1.4 中向下的虚线箭头）和它们之间的通信（图 1.4 中水平的虚线箭头）。

过去的并行 Fortran 编程要么仅使用 OpenMP 指令用于共享内存计算机，要么使用消息传递接口（MPI）用于共享和分布式内存计算机。共享内存（SM）和分布式内存（DM）系统的差异如图 1.5 所示。SM 系统的主要优势是进程间通信的延迟非常低。然而，SM 系统中处理核心的数量有限。由于 OpenMP 专为 SM 并行编程设计，我们将专注于具体示例中的 MPI。

<a>![](/img/modernfortran/ch1/6.png)</a>
**图 1.5 共享内存系统（左）与分布式内存系统（右）。在共享内存系统中，处理器可以访问共同的内存（RAM）。在分布式内存系统中，每个处理器都有自己的内存，它们通过网络交换数据，用虚线表示。分布式内存系统通常由多核共享内存系统组成。**

**OpenMP 与 MPI**

OpenMP 是一组指令(directives)，允许程序员向编译器指示要并行化的代码部分。大多数 Fortran 编译器都实现了 OpenMP，不需要外部库。然而，OpenMP 仅限于共享内存机器。

消息传递接口（MPI）是一个用于便携消息传递（复制数据）在任意远程进程之间的标准化规范。这意味着 MPI 可用于单核上的多线程、共享内存机器上的多核处理或跨网络的分布式内存编程。MPI 实现通常提供 C、C++ 和 Fortran 接口。MPI 通常被描述为并行编程的汇编语言，说明大多数 MPI 操作都是低级的。

尽管在高性能计算（HPC）中仍然普遍使用，但 OpenMP 和 MPI 是特定的并行计算方法，可以用协数组更优雅地表达。本书将专注于使用协数组进行并行编程。 

### 1.7.1 将数组从一个处理器复制到另一个处理器

在大多数科学和工程并行应用中，进程之间存在数据依赖性。通常，一个二维数组被分解成像棋盘一样的块，每个块的工作负载被分配给一个处理器。每个块都有其在处理器本地的内存中的数据。为了说明现实场景中最简单的并行编程情况，我们以以下气象情况为例。假设数据包括两个变量：风和空气温度。风从温度较低的块（冷块）吹向温度较高的块（热块）。如果我们要解决温度随时间变化的问题，热块需要知道风从冷块带来的温度。由于这是未知的（记住数据是本地的），我们需要将数据从冷块复制到属于热块的内存中。在最低层级上，这通过显式地将数据从一个处理器复制到另一个处理器来完成。当复制完成后，处理器可以继续进行剩余的计算。将一个或多个值从一个进程复制到另一个进程是并行编程中最常见的操作（图1.6）。

<a>![](/img/modernfortran/ch1/7.png)</a>
**图 1.6 两个CPU之间远程数组复制的示意图。框内的数字表示数组的初始值。我们的目标是将数组的值从CPU 1复制到CPU 2。**

让我们专注于这一操作。我们的目标如下：

* 初始化每个进程上的数组——在CPU 1上的数组为[1, 2, 3, 4, 5]，在CPU 2上的数组全为零。
* 将数组的值从CPU 1复制到CPU 2。
* 打印CPU 2上的新数组值，这些值应该是[1, 2, 3, 4, 5]。

我将向你展示两个解决此问题的示例方案。一个是使用外部库（如MPI）的传统方法。除非你是一个有经验的Fortran程序员，否则不要试图理解这个示例中的每一个细节。我只是想展示它的复杂性和冗长性。然后，我会向你展示使用协程数组（coarrays）的解决方案。与MPI不同，协程数组使用类似于数组索引的语法在并行进程之间复制远程数据。


#### MPI：传统的并行编程方式

如前所述，MPI通常被描述为并行编程的汇编语言，实际上，这也是其开发者的初衷。MPI的目的是由编译器开发者实现，以支持本地并行编程语言。然而，在过去的三十年中，应用程序开发者更快地直接在他们的程序中采用MPI，并且MPI已经成为Fortran、C和C++中并行编程的事实标准工具。因此，今天大多数HPC应用程序都依赖于低级的MPI调用。

以下Fortran程序使用MPI将数据从一个进程发送到另一个进程。

```fortran
program array_copy_mpi
  ! Example of sending/receiving an array of integers using MPI.
  ! Listing 1.2 in the book.
  use mpi
  implicit none

  integer :: ierr, nproc, procsize, request
  integer :: stat(mpi_status_size)

  integer :: array(5) = 0
  integer, parameter :: sender = 0, receiver = 1

  call mpi_init(ierr)
  call mpi_comm_rank(mpi_comm_world, nproc, ierr)
  call mpi_comm_size(mpi_comm_world, procsize, ierr)

  if (procsize /= 2) then
    call mpi_finalize(ierr)
    error stop 'Error: This program must be run on 2 parallel processes'
  end if

  if (nproc == sender) array = [1, 2, 3, 4, 5]

  print '(a,i2,a,5(4x,i2))', 'array on proc ', nproc, ' before copy:', array

  call mpi_barrier(mpi_comm_world, ierr)

  if (nproc == sender) then
    call mpi_isend(array, size(array), mpi_int, receiver, 1, &
                   mpi_comm_world, request, ierr)
  else if (nproc == receiver) then
    call mpi_irecv(array, size(array), mpi_int, sender, 1, &
                   mpi_comm_world, request, ierr)
    call mpi_wait(request, stat, ierr)
  end if

  print '(a,i2,a,5(4x,i2))', 'array on proc ', nproc, ' after copy: ', array

  call mpi_finalize(ierr)

end program array_copy_mpi
```

在两个处理器上运行该程序将输出以下内容：

```
array on proc  0 before copy:     1     2     3     4     5
array on proc  1 before copy:     0     0     0     0     0
array on proc  0 after copy:      1     2     3     4     5
array on proc  1 after copy:      1     2     3     4     5
```



这确认了我们的程序实现了预期的目标：将数组从进程0复制到进程1。

**编译和运行示例**

暂时不用担心自己构建和运行这些示例。在下一章开始时，我会请你设置完整的计算环境，以便使用本书中的示例，包括这个示例。如果你愿意，也可以现在按照附录A中的说明操作，而不是等待。



#### 进入 Fortran Coarrays

Coarrays 是 Fortran 中本地并行编程的主要数据结构。它们最初由 Robert Numrich 和 John Reid 于 1990 年代作为 Cray Fortran 编译器的扩展开发，自 2008 版起被引入标准。正如名字所暗示的那样，Coarrays 类似于数组，不同之处在于它们的元素沿着并行进程（内核或线程）轴分布。因此，它们提供了一种直观的方式来在远程进程之间复制数据。

以下列出了我们的数组复制示例的 coarray 版本。

```fortran
program array_copy_caf
  ! Example of sending/receiving an array of integers using coarrays.
  ! Listing 1.3 in the book.
  implicit none

  integer :: array(5)[*] = 0
  integer, parameter :: sender = 1, receiver = 2

  if (num_images() /= 2) &
    error stop 'Error: This program must be run on 2 parallel processes'

  if (this_image() == sender) array = [1, 2, 3, 4, 5]

  print '(a,i2,a,5(4x,i2))', &
    'array on proc ', this_image(), ' before copy:', array

  sync all

  if (this_image() == receiver) array(:) = array(:)[sender]

  print '(a,i2,a,5(4x,i2))', &
    'array on proc ', this_image(), ' after copy: ', array

end program array_copy_caf
```
程序的输出与 MPI 变体相同：

```
array on proc  1 before copy:     1     2     3     4     5
array on proc  1 after copy:      1     2     3     4     5
array on proc  2 before copy:     0     0     0     0     0
array on proc  2 after copy:      1     2     3     4     5
```


这两个程序在语义上是相同的。让我们看看代码中的关键区别：

* 代码行数（LOC）从 MPI 示例中的 27 行减少到 coarray 示例中的 14 行。这几乎减少了一半。然而，如果我们具体查看与 MPI 相关的样板代码，可以数出有 15 行这样的代码。相比之下，与 coarray 相关的代码只有两行！由于调试时间大致与代码行数成正比，我们可以看到使用 coarray 开发并行 Fortran 应用程序更具成本效益。

与直观的数组索引和赋值语法相比，MPI 示例中的数据复制核心对于如此简单的操作来说显得相当冗长：

```fortran
  if (nproc == sender) then
    call mpi_isend(array, size(array), mpi_int, receiver, 1, &
                   mpi_comm_world, request, ierr)
  else if (nproc == receiver) then
    call mpi_irecv(array, size(array), mpi_int, sender, 1, &
                   mpi_comm_world, request, ierr)
    call mpi_wait(request, stat, ierr)
  end if
```

而coarrays为：

```fortran
if (this_image() == receiver) array(:) = array(:)[sender]
```

* 最后，MPI 需要使用 mpi_init() 和 mpi_finalize() 子程序进行初始化和终止。Coarrays 不需要这样的代码。这是一个小但受欢迎的改进。

**并行进程索引**

你注意到我们的并行进程在 MPI 示例中被索引为 0 和 1，而在 coarray 示例中被索引为 1 和 2 吗？MPI 在 C 中实现，其中数组索引从 0 开始。相比之下，coarray 图像(image，似乎应该翻译成镜像比较好)默认从 1 开始。

如我们在此示例中所见，MPI 和 coarrays 都可以有效地用于在并行进程之间复制数据。然而，MPI 代码是低级且冗长的，随着你的应用程序规模和复杂性增加，它很快会变得乏味且容易出错。Coarrays 提供了类似数组操作的直观语法。此外，使用 MPI，你告诉编译器该做什么；使用 coarrays，你告诉编译器你想要什么，并让它决定如何最好地实现。这减轻了你肩上的重担，让你专注于你的应用程序。我希望这能说服你，Fortran coarrays 是实现并行进程之间数据复制的表达性和直观性的最佳选择。

**一个分区全局地址空间语言**

Fortran 是一种分区全局地址空间（PGAS）语言。简而言之，PGAS 抽象了分布式内存空间，使你可以做到以下几点：

* 将内存布局视为共享内存空间——这将在设计并行算法时大大提高你的生产力和编程的容易性。在执行数据复制时，你无需将数组索引从一个图像转换或变换到另一个图像。属于远程图像的内存将显示为本地内存，你可以用这种方式表达你的算法。

* 利用引用的局部性——你可以设计和编写并行算法，而无需预见某个内存子区是否对当前图像是本地的。如果是，本地编译器会利用这些信息。如果不是，将执行可用的最有效数据复制模式。

PGAS 允许你使用一个图像来启动两个远程图像之间的数据复制：

```fortran
if (this_image() == 1) array(:)[7] = array(:)[8]
```

if 语句确保赋值仅在图像 1 上执行。然而，方括号内的索引指的是图像 7 和 8。因此，图像 1 将异步请求从图像 8 到图像 7 的数组复制。从我们的角度来看，方括号内的索引可以像任何其他本地内存中的数组元素一样对待。在实际应用中，这些图像可以映射到同一共享内存计算机上的不同内核、服务器室内，甚至世界各地。

## 1.8 运行示例：并行海啸(tsunami)模拟器

学习通过实践而非阅读来进行，特别是当我们沉浸在一个较长项目中时。因此，本书中的课程围绕着开发您自己的、简洁而完整的海啸模拟器展开。

### 1.8.1 为什么选择海啸模拟器？

海啸是由大规模水体位移引发的一系列长水波。这通常是由地震、水下火山或山体滑坡引起的。一旦生成，海啸会径向向外传播到海洋表面。当它进入浅水区时，其高度和陡度会增长。海啸模拟器是本书的一个很好的运行示例，因为海啸具有以下特点：

* 有趣——严格说来，作为一个科学家！海啸是一个在数值沙盒中观察和玩耍的有趣过程。
* 危险——海啸对低洼和人口稠密的沿海地区构成巨大威胁。有必要更好地理解和预测它们。
* 简单的数学——它们可以使用最简单的方程组进行模拟——浅水方程（SWEs）。这将帮助我们不陷入数学中，而是专注于实现过程。
* 可并行化——它们涉及一个适合教授并行编程的物理过程，尤其是考虑到它是一个非显而易见并行问题。为使其正常工作，我们将仔细设计图像之间的数据复制模式。

为了模拟海啸，我们将编写一个解浅水方程组的求解器。


### 1.8.2 Shallow Water Equations (SWEs) 

浅水方程组是从 Navier-Stokes 方程推导出来的一组简单方程组。它们也被称为 Saint-Venant 方程，以法国工程师和数学家 A. J. C. Barre de Saint-Venant 的名字命名，他在研究水利工程和开放河道流动方面推导了这些方程。SWEs 具有很强的能力，因为它们可以重现大气和海洋中许多观察到的运动：

* 大尺度天气现象，如气旋和反气旋
* 西边界流，如大西洋的墨西哥湾流和太平洋的黑潮
* 长引力波，如海啸和潮汐波(tidal bores)
* 由降雨和融雪形成的流域
* 风生成的（冲浪）波浪
* 池塘中的涟漪

这个系统只包含几个术语，如图1.7所示。

<a>![](/img/modernfortran/ch1/8.png)</a>
**图1.7 浅水方程。顶部方程是动量（速度）守恒定律，底部方程是质量（水位）守恒定律。u 是二维速度矢量，g 是重力加速度，h 是水位高度，H 是未受干扰的水深，t 是时间。符号“nabla”（倒三角形）是一个矢量微分算子。**

这个系统的物理解释是什么？顶部方程表明，在水面上存在坡度的地方，水会因压力梯度而加速并向较低水平的区域移动。对流项是非线性的，会导致流体（湍流）中的混乱行为。底部方程表明，在汇聚的地方（水汇集到一起），水位会增加。这是因为水必须流向某个地方，这也是我们称之为质量守恒的原因。同样地，如果水发散，它的水位会下降。

对数学熟悉吗？如果你熟悉微积分和偏微分方程，那太好了！附录B中还有更多内容供你参考。否则，不用担心！这本书不会过多涉及数学；它将专注于编程。

对我来说，浅水方程非常重要，因为我最初是通过在贝尔格莱德大学气象学本科项目中建模这些方程来学习Fortran编程的。在写这本书的过程中，我有点回到了最初的阶段。尽管我的Fortran代码现在看起来（而且工作方式）与过去不同，但我仍然认为这个例子是教授并行Fortran编程的理想案例研究。希望你和我一样享受这个过程。


### 1.8.3 我们要做什么

我们希望我们的应用做到以下几点：

* 并行化 - 模型将仅使用纯Fortran代码扩展到数百个处理器。这不仅对加快程序运行速度和减少计算时间至关重要，而且对于启用其他情况下无法适应单台计算机内存的非常大模拟也是必要的。由于大多数现代笔记本电脑至少具有四个核心，您应该能够享受并行编程的成果。

* 可扩展性 - 物理术语可以轻松地被规范并添加到求解器中。这对于模型的一般可用性非常重要。如果我们可以将计算内核设计为可重复使用的类和函数形式，那么我们可以轻松地将新的物理术语作为功能并行操作符添加，遵循达米安·鲁森（Damian Rouson）的方法。这样，技术实现被抽象化到这些函数中，高层次上我们可以像在黑板上写方程一样编程。

* 软件库 - 这将提供一组可重复使用的类和函数，可用于构建其他并行模型。

* 文档化 - 所有软件都应该是有用的，用户不应该去猜测程序作者的意图。我们将以一种易于阅读和理解的方式编写和记录我们的应用程序。

* 在线发现 - 为自己编写程序很有益于学习和发现。然而，当您可以与他人分享它来解决他们的问题时，软件才真正有用。这本书中开发的海啸模拟器和其他项目都在 https://github.com/modern-fortran 上在线。随时探索它们，我们将一起深入研究细节，直到完成这本书。

通过逐章阅读这本书，您将获得从头开始开发完整功能并行应用程序的经验。如果这是您的第一个软件项目，我希望它能激发您内心的软件开发者，并激励您去创造自己的东西。我们将通过设置开发环境来开始下一章，以便您可以编译和运行海啸模拟器的最小工作版本。

**可视化海啸输出**

当我们构建和运行我们的模拟器时，我们将主要查看它记录到终端的原始数字和时间步长计数。然而，能够可视化模型的输出既有帮助又令人满足。每当我们向模拟器添加新部分时，我们都会这样做，这样可以使解决方案变得不同并且更加有趣。我在项目的 GitHub 存储库中提供了 Python 脚本，以便您自己可视化输出。虽然可以直接从 Fortran 创建高质量的图形，但这并不像使用 Python 那样容易。




## 1.9 一步阅读：

* Fortran官方网站：https://fortran-lang.org
* Fortran历史：https://en.wikipedia.org/wiki/Fortran
* 分区全局地址空间：http://mng.bz/4A6g
* 本书的伴随博客：https://medium.com/modern-fortran

##总结

* Fortran是今天仍在使用的最古老的高级编程语言。
* 它是许多科学和工程应用中使用的主要语言。
* Fortran不适合编写视频游戏或网页浏览器，但在大型多维数组上进行数字、并行计算方面表现出色。
* 它是唯一标准化的本地并行编程语言。
* Coarrays提供了比传统的消息传递接口（MPI）编程更清晰、更具表达力的并行数据交换语法。
* Fortran编译器和库经过了成熟和经受考验的。




